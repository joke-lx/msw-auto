# 部署运维方案

## 一、部署架构

### 1.1 环境分层

```
开发环境（Development）
├── 本地开发
│   ├── Mock 服务器 (localhost:4000)
│   ├── Web UI (localhost:4001)
│   └── 前端应用 (localhost:3000)
│
└── 团队开发
    ├── 共享 Mock 服务器 (dev.example.com)
    ├── 共享数据库 (SQLite)
    └── 多个开发者前端应用

测试环境（Staging）
├── Mock 服务器 (staging-mock.example.com)
├── 真实后端 (staging-api.example.com)
├── 前端应用 (staging.example.com)
└── CI/CD 自动部署

生产环境（Production）
├── Mock 服务器（可选，生产禁用）
├── 真实后端 (api.example.com)
├── 前端应用 (example.com)
└── 高可用部署 + 负载均衡
```

### 1.2 生产架构

```
┌─────────────────────────────────────────────────────────────┐
│                      用户                               │
└────────────────┬────────────────────────────────────────┘
                 │
                 ↓
        ┌──────────────────┐
        │   CDN / 负载均衡  │
        │  (CloudFlare/ALB) │
        └────────┬─────────┘
                 │
        ┌────────┴─────────┐
        │                  │
        ↓                  ↓
┌──────────────┐   ┌──────────────┐
│  前端应用     │   │  Mock 服务    │
│  (Nginx)     │   │  (Node.js)   │
└──────┬───────┘   └──────┬───────┘
       │                   │
       └────────┬──────────┘
                ↓
        ┌──────────────┐
        │  真实后端    │
        │ (API Server)  │
        └──────┬───────┘
               │
        ┌──────┴────────┐
        │               │
        ↓               ↓
┌─────────────┐  ┌─────────────┐
│ PostgreSQL  │  │   Redis     │
│   数据库     │  │   缓存      │
└─────────────┘  └─────────────┘
```

---

## 二、Docker 部署

### 2.1 Dockerfile

```dockerfile
# Multi-stage build
# Stage 1: Build
FROM node:18-alpine AS builder

WORKDIR /app

# 安装依赖
COPY package*.json ./
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建 Web UI
RUN npm run build:web-ui

# 构建后端
RUN npm run build

# Stage 2: Runtime
FROM node:18-alpine

WORKDIR /app

# 安装生产依赖
COPY package*.json ./
RUN npm ci --only=production

# 从构建阶段复制文件
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/web-ui/dist ./web-ui
COPY --from=builder /app/node_modules ./node_modules

# 创建数据目录
RUN mkdir -p /app/data /app/logs

# 暴露端口
EXPOSE 4000 4001

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD node -e "require('http').get('http://localhost:4000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"

# 非特权用户
USER node

# 启动应用
CMD ["node", "dist/server/index.js"]
```

### 2.2 Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Mock 服务器
  mock-server:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - '4000:4000'
      - '4001:4001'
    environment:
      - NODE_ENV=production
      - PORT=4000
      - WEB_UI_PORT=4001
      - BACKEND_URL=http://backend:3000
      - CLAUDE_API_KEY=${CLAUDE_API_KEY}
      - DATABASE_URL=postgresql://mockuser:mockpass@postgres:5432/mocks
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - JWT_SECRET=${JWT_SECRET}
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    networks:
      - mock-network
    healthcheck:
      test:
        [
          'CMD',
          'node',
          '-e',
          "require('http').get('http://localhost:4000/health')",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # PostgreSQL 数据库
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=mocks
      - POSTGRES_USER=mockuser
      - POSTGRES_PASSWORD=mockpass
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - '5432:5432'
    restart: unless-stopped
    networks:
      - mock-network

  # Redis 缓存
  redis:
    image: redis:7-alpine
    ports:
      - '6379:6379'
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    restart: unless-stopped
    networks:
      - mock-network

  # Nginx 反向代理
  nginx:
    image: nginx:alpine
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - mock-server
    restart: unless-stopped
    networks:
      - mock-network

volumes:
  postgres_data:
  redis_data:

networks:
  mock-network:
    driver: bridge
```

---

## 三、Kubernetes 部署

### 3.1 Deployment 配置

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mock-server
  namespace: mock-server
  labels:
    app: mock-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mock-server
  template:
    metadata:
      labels:
        app: mock-server
    spec:
      containers:
        - name: mock-server
          image: mock-server:latest
          ports:
            - containerPort: 4000
              name: api
            - containerPort: 4001
              name: web-ui
          env:
            - name: NODE_ENV
              value: 'production'
            - name: PORT
              value: '4000'
            - name: WEB_UI_PORT
              value: '4001'
            - name: BACKEND_URL
              value: 'http://backend-service:3000'
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: mock-server-secrets
                  key: database-url
            - name: CLAUDE_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mock-server-secrets
                  key: claude-api-key
            - name: JWT_SECRET
              valueFrom:
                secretKeyRef:
                  name: mock-server-secrets
                  key: jwt-secret
          resources:
            requests:
              memory: '256Mi'
              cpu: '250m'
            limits:
              memory: '512Mi'
              cpu: '500m'
          livenessProbe:
            httpGet:
              path: /health
              port: 4000
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /health
              port: 4000
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 1
```

### 3.2 Service 配置

```yaml
# k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: mock-server-service
  namespace: mock-server
spec:
  selector:
    app: mock-server
  ports:
    - name: api
      port: 4000
      targetPort: 4000
    - name: web-ui
      port: 4001
      targetPort: 4001
  type: LoadBalancer
---
apiVersion: v1
kind: Service
metadata:
  name: mock-server-internal
  namespace: mock-server
spec:
  selector:
    app: mock-server
  ports:
    - port: 4000
      targetPort: 4000
  type: ClusterIP
```

### 3.3 Ingress 配置

```yaml
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mock-server-ingress
  namespace: mock-server
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: 'true'
    nginx.ingress.kubernetes.com/proxy-body-size: '10m'
spec:
  tls:
    - hosts:
        - mock.example.com
        - ui.mock.example.com
      secretName: mock-server-tls
  rules:
    - host: mock.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: mock-server-service
                port:
                  number: 4000
    - host: ui.mock.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: mock-server-service
                port:
                  number: 4001
```

---

## 四、监控和日志

### 4.1 Prometheus 监控

```typescript
// src/monitoring/prometheus.ts
import express from 'express'
import { register, collectDefaultMetrics } from 'prom-client'

// 初始化 Prometheus
collectDefaultMetrics()

// 自定义指标
export const metrics = {
  httpRequestsTotal: new register.Counter({
    name: 'http_requests_total',
    help: 'Total number of HTTP requests',
    labelNames: ['method', 'route', 'status_code'],
  }),

  httpRequestDuration: new register.Histogram({
    name: 'http_request_duration_seconds',
    help: 'HTTP request duration in seconds',
    labelNames: ['method', 'route'],
    buckets: [0.1, 0.5, 1, 2, 5, 10],
  }),

  mockHitRate: new register.Gauge({
    name: 'mock_hit_rate',
    help: 'Mock hit rate percentage',
  }),

  activeMocksCount: new register.Gauge({
    name: 'active_mocks_count',
    help: 'Number of active mocks',
  }),

  claudeAPICalls: new register.Counter({
    name: 'claude_api_calls_total',
    help: 'Total number of Claude API calls',
    labelNames: ['model', 'success'],
  }),

  claudeAPITokens: new register.Counter({
    name: 'claude_api_tokens_total',
    help: 'Total Claude API tokens used',
    labelNames: ['model', 'type'],
  }),
}

// 中间件
export function prometheusMiddleware(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction,
) {
  const start = Date.now()

  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000
    metrics.httpRequestsTotal.inc({
      method: req.method,
      route: req.route?.path || req.path,
      status_code: res.statusCode,
    })
    metrics.httpRequestDuration.observe(
      { method: req.method, route: req.route?.path || req.path },
      duration,
    )
  })

  next()
}

// 指标端点
export function setupMetricsEndpoint(app: express.Express) {
  app.get('/metrics', async (req, res) => {
    res.set('Content-Type', register.contentType)
    res.end(await register.metrics())
  })
}
```

### 4.2 Grafana Dashboard

```json
{
  "dashboard": {
    "title": "Mock Server Monitoring",
    "panels": [
      {
        "title": "请求速率",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])"
          }
        ]
      },
      {
        "title": "响应时间",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, http_request_duration_seconds)"
          }
        ]
      },
      {
        "title": "Mock 命中率",
        "targets": [
          {
            "expr": "mock_hit_rate"
          }
        ]
      },
      {
        "title": "Claude API 调用",
        "targets": [
          {
            "expr": "rate(claude_api_calls_total[5m])"
          }
        ]
      },
      {
        "title": "活跃 Mock 数量",
        "targets": [
          {
            "expr": "active_mocks_count"
          }
        ]
      }
    ]
  }
}
```

### 4.3 日志聚合

```typescript
// src/logging/winston.ts
import winston from 'winston'
import { ElasticsearchTransport } from 'winston-elasticsearch'

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json(),
  ),
  transports: [
    // 控制台输出
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple(),
      ),
    }),

    // 文件输出
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    }),

    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880,
      maxFiles: 5,
    }),

    // Elasticsearch（生产环境）
    process.env.NODE_ENV === 'production' &&
      new ElasticsearchTransport({
        level: 'info',
        clientOpts: {
          node: process.env.ELASTICSEARCH_URL,
        },
        index: 'mock-server-logs',
      }),
  ].filter(Boolean),
})

export default logger
```

---

## 五、CI/CD 流程

### 5.1 GitHub Actions 工作流

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  # 测试
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: npm ci

      - name: Lint
        run: npm run lint

      - name: Type check
        run: npm run type-check

      - name: Run tests
        run: npm run test
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/mocks

      - name: Upload coverage
        uses: codecov/codecov-action@v3

  # 构建
  build:
    needs: test
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/mock-server:latest
            ${{ secrets.DOCKER_USERNAME }}/mock-server:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # 部署到 Staging
  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'

    steps:
      - uses: actions/checkout@v3

      - name: Deploy to Staging
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /app/mock-server
            docker-compose pull
            docker-compose up -d
            docker-compose exec -T npm run migrate

  # 部署到 Production
  deploy-production:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v3

      - name: Deploy to Production
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /app/mock-server
            docker-compose pull
            docker-compose up -d
            docker-compose exec -T npm run migrate
            kubectl rollout restart deployment/mock-server -n mock-server
```

### 5.2 Docker Hub 自动构建

```yaml
# .dockerhub-build.yml
name: Docker Hub Build

on:
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'

jobs:
  build-push:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/mock-server:latest
            ${{ secrets.DOCKER_USERNAME }}/mock-server:${{ github.ref_name }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

---

## 六、备份和恢复

### 6.1 数据库备份

```bash
#!/bin/bash
# scripts/backup.sh

# 配置
BACKUP_DIR="/backups"
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME="mocks"
DB_USER="mockuser"
DB_HOST="postgres"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 备份 PostgreSQL
echo "Backing up PostgreSQL..."
PGPASSWORD="$DB_PASSWORD" pg_dump -h "$DB_HOST" -U "$DB_USER" "$DB_NAME" > "$BACKUP_DIR/postgres_$DATE.sql"

# 压缩备份
echo "Compressing backup..."
gzip "$BACKUP_DIR/postgres_$DATE.sql"

# 删除 7 天前的备份
find "$BACKUP_DIR" -name "*.sql.gz" -mtime +7 -delete

echo "Backup completed: postgres_$DATE.sql.gz"
```

### 6.2 定时备份（Cron）

```yaml
# k8s/backup-cronjob.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: database-backup
  namespace: mock-server
spec:
  schedule: '0 2 * * *' # 每天凌晨 2 点
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: backup
              image: postgres:15-alpine
              command:
                - /bin/sh
                - -c
                - |
                  apk add --no-cache postgresql-client
                  PGPASSWORD="$DB_PASSWORD" pg_dump -h "$DB_HOST" -U "$DB_USER" "$DB_NAME" > /backup/postgres_$(date +%Y%m%d).sql
                  gzip /backup/postgres_$(date +%Y%m%d).sql
              env:
                - name: DB_HOST
                  valueFrom:
                    secretKeyRef:
                      name: mock-server-secrets
                      key: database-host
                - name: DB_USER
                  valueFrom:
                    secretKeyRef:
                      name: mock-server-secrets
                      key: database-user
                - name: DB_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: mock-server-secrets
                      key: database-password
                - name: DB_NAME
                  value: 'mocks'
              volumeMounts:
                - name: backup-storage
                  mountPath: /backup
          restartPolicy: OnFailure
          volumes:
            - name: backup-storage
              persistentVolumeClaim:
                claimName: backup-pvc
```

---

## 七、性能优化

### 7.1 Nginx 配置

```nginx
# nginx/nginx.conf
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 2048;
    use epoll;
    multi_accept on;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 10M;

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript application/xml+rss application/rss+xml font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml;

    # Mock API 上游
    upstream mock_api {
        least_conn;
        server mock-server:4000 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # Web UI 上游
    upstream mock_web_ui {
        least_conn;
        server mock-server:4001 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # HTTP 重定向到 HTTPS
    server {
        listen 80;
        server_name mock.example.com ui.mock.example.com;
        return 301 https://$host$request_uri;
    }

    # HTTPS 服务器
    server {
        listen 443 ssl http2;
        server_name mock.example.com ui.mock.example.com;

        # SSL 证书
        ssl_certificate /etc/nginx/ssl/fullchain.pem;
        ssl_certificate_key /etc/nginx/ssl/privkey.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

        # 安全头
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;
        add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

        # Mock API 代理
        location / {
            proxy_pass http://mock_api;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # 超时设置
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;

            # 缓存配置
            proxy_cache_bypass $http_upgrade;
            proxy_no_cache $http_upgrade;
        }

        # WebSocket 支持
        location /ws {
            proxy_pass http://mock_api;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}
```

### 7.2 Redis 缓存配置

```typescript
// src/cache/redis-cache.ts
import Redis from 'ioredis'

export class RedisCache {
  private client: Redis
  private defaultTTL = 3600 // 1 hour

  constructor() {
    this.client = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      db: 0,
      retryStrategy: (times) => {
        const delay = Math.min(times * 50, 2000)
        return delay
      },
      maxRetriesPerRequest: 3,
    })

    this.client.on('error', (error) => {
      console.error('Redis error:', error)
    })
  }

  async get<T>(key: string): Promise<T | null> {
    const value = await this.client.get(key)
    return value ? JSON.parse(value) : null
  }

  async set(key: string, value: any, ttl?: number): Promise<void> {
    const serialized = JSON.stringify(value)
    await this.client.setex(key, ttl || this.defaultTTL, serialized)
  }

  async delete(key: string): Promise<void> {
    await this.client.del(key)
  }

  async deletePattern(pattern: string): Promise<void> {
    const keys = await this.client.keys(pattern)
    if (keys.length > 0) {
      await this.client.del(...keys)
    }
  }

  async exists(key: string): Promise<boolean> {
    return (await this.client.exists(key)) === 1
  }

  async flush(): Promise<void> {
    await this.client.flushdb()
  }

  async disconnect(): Promise<void> {
    await this.client.quit()
  }
}
```

---

## 八、总结

部署运维方案提供了：

✅ **完整的部署方案**：Docker、Kubernetes、传统部署
✅ **高可用架构**：负载均衡、多实例部署
✅ **监控告警**：Prometheus + Grafana
✅ **日志聚合**：Winston + Elasticsearch
✅ **CI/CD 流程**：GitHub Actions 自动化
✅ **备份恢复**：定时备份和恢复策略
✅ **性能优化**：Nginx + Redis 缓存

核心优势：

- **自动化**：完全自动化的 CI/CD 流程
- **可扩展**：水平扩展支持
- **可靠性**：高可用和容灾设计
- **监控完善**：全面的监控和告警
- **成本优化**：资源利用率和成本控制
