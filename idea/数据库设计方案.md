# 数据库设计方案

## 一、数据库选型

### 1.1 技术对比

| 特性       | SQLite    | PostgreSQL      | MySQL         |
| ---------- | --------- | --------------- | ------------- |
| 部署复杂度 | ⭐ 极简   | ⭐⭐⭐ 复杂     | ⭐⭐ 中等     |
| 性能       | ⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 优秀 | ⭐⭐⭐⭐ 很好 |
| 并发能力   | ⭐⭐ 有限 | ⭐⭐⭐⭐⭐ 优秀 | ⭐⭐⭐⭐ 很好 |
| 迁移成本   | ⭐ 低     | ⭐⭐⭐ 高       | ⭐⭐ 中等     |
| 适合场景   | 开发/测试 | 生产环境        | 生产环境      |

### 1.2 选型建议

- **开发环境**：SQLite（零配置、即插即用）
- **生产环境**：PostgreSQL（高性能、功能丰富）
- **混合模式**：开发用 SQLite，生产自动迁移到 PostgreSQL

---

## 二、数据库架构

### 2.1 ER 图

```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│   Users     │         │    Mocks    │         │  Requests   │
├─────────────┤         ├─────────────┤         ├─────────────┤
│ id (PK)     │         │ id (PK)     │         │ id (PK)     │
│ email       │         │ method      │         │ method      │
│ name        │         │ path        │         │ url         │
│ password    │         │ status      │         │ path        │
│ role        │         │ response    │         │ headers     │
│ created_at  │         │ headers     │         │ body        │
│ updated_at  │         │ enabled     │         │ response    │
│             │         │ created_at  │         │ status      │
└─────────────┘         │ updated_at  │         │ is_mocked   │
        │               │ created_by (FK)→Users│ timestamp   │
        │               └─────────────┘         └─────────────┘
        │                      │                        │
        └──────────────────────┴────────────────────────┘
                                   │
                          ┌────────┴────────┐
                          ↓                 ↓
                  ┌─────────────┐   ┌─────────────┐
                  │  Sessions   │   │  Versions   │
                  ├─────────────┤   ├─────────────┤
                  │ id (PK)     │   │ id (PK)     │
                  │ user_id (FK)│   │ mock_id (FK)│
                  │ token       │   │ version     │
                  │ created_at  │   │ response    │
                  │ expires_at  │   │ created_at  │
                  └─────────────┘   │ created_by (FK)│
                                   └─────────────┘
```

### 2.2 表结构设计

#### 2.2.1 Users 表（用户表）

```sql
CREATE TABLE users (
    id TEXT PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    password_hash TEXT NOT NULL,
    role TEXT NOT NULL DEFAULT 'user',
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    last_login_at TEXT
);

-- 索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
```

**字段说明：**

- `id`: 用户唯一标识（UUID）
- `email`: 邮箱地址，唯一
- `name`: 用户名
- `password_hash`: 密码哈希（bcrypt）
- `role`: 角色（admin, user, viewer）
- `created_at`: 创建时间（ISO 8601）
- `updated_at`: 更新时间（ISO 8601）
- `last_login_at`: 最后登录时间

#### 2.2.2 Mocks 表（Mock 数据表）

```sql
CREATE TABLE mocks (
    id TEXT PRIMARY KEY,
    method TEXT NOT NULL,
    path TEXT NOT NULL,
    status INTEGER DEFAULT 200,
    response TEXT NOT NULL,
    headers TEXT,
    cookies TEXT,
    query_params TEXT,
    request_headers TEXT,
    request_body TEXT,
    delay INTEGER DEFAULT 0,
    enabled INTEGER DEFAULT 1,
    dynamic_response INTEGER DEFAULT 0,
    description TEXT,
    tags TEXT,
    version INTEGER DEFAULT 1,
    created_by TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL
);

-- 索引
CREATE INDEX idx_mocks_method_path ON mocks(method, path);
CREATE INDEX idx_mocks_enabled ON mocks(enabled);
CREATE INDEX idx_mocks_tags ON mocks(tags);
CREATE INDEX idx_mocks_created_by ON mocks(created_by);
```

**字段说明：**

- `id`: Mock 唯一标识（UUID）
- `method`: HTTP 方法（GET, POST, PUT, DELETE）
- `path`: API 路径（支持参数，如 `/users/:id`）
- `status`: 响应状态码
- `response`: 响应体（JSON 字符串）
- `headers`: 响应头（JSON 字符串）
- `cookies`: Cookies（JSON 字符串）
- `query_params`: 查询参数匹配规则（JSON 字符串）
- `request_headers`: 请求头匹配规则（JSON 字符串）
- `request_body`: 请求体匹配规则（JSON 字符串）
- `delay`: 响应延迟（毫秒）
- `enabled`: 是否启用（0/1）
- `dynamic_response`: 是否动态响应（0/1）
- `description`: 描述
- `tags`: 标签（逗号分隔）
- `version`: 版本号
- `created_by`: 创建者 ID（外键）
- `created_at`: 创建时间
- `updated_at`: 更新时间

#### 2.2.3 Requests 表（请求日志表）

```sql
CREATE TABLE requests (
    id TEXT PRIMARY KEY,
    method TEXT NOT NULL,
    url TEXT NOT NULL,
    path TEXT NOT NULL,
    query TEXT,
    headers TEXT NOT NULL,
    body TEXT,
    response_status INTEGER,
    response_body TEXT,
    response_time INTEGER,
    is_mocked INTEGER DEFAULT 0,
    mock_id TEXT,
    ip_address TEXT,
    user_agent TEXT,
    timestamp TEXT NOT NULL,
    FOREIGN KEY (mock_id) REFERENCES mocks(id) ON DELETE SET NULL
);

-- 索引
CREATE INDEX idx_requests_timestamp ON requests(timestamp DESC);
CREATE INDEX idx_requests_method_path ON requests(method, path);
CREATE INDEX idx_requests_mock_id ON requests(mock_id);
CREATE INDEX idx_requests_is_mocked ON requests(is_mocked);
```

**字段说明：**

- `id`: 请求唯一标识
- `method`: HTTP 方法
- `url`: 完整 URL
- `path`: 路径
- `query`: 查询参数（JSON 字符串）
- `headers`: 请求头（JSON 字符串）
- `body`: 请求体
- `response_status`: 响应状态码
- `response_body`: 响应体
- `response_time`: 响应时间（毫秒）
- `is_mocked`: 是否使用 Mock（0/1）
- `mock_id`: 使用的 Mock ID
- `ip_address`: 客户端 IP
- `user_agent`: User-Agent
- `timestamp`: 请求时间

#### 2.2.4 Sessions 表（会话表）

```sql
CREATE TABLE sessions (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    token TEXT UNIQUE NOT NULL,
    created_at TEXT NOT NULL,
    expires_at TEXT NOT NULL,
    last_activity_at TEXT,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_token ON sessions(token);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);
```

**字段说明：**

- `id`: 会话唯一标识
- `user_id`: 用户 ID（外键）
- `token`: 会话 Token
- `created_at`: 创建时间
- `expires_at`: 过期时间
- `last_activity_at`: 最后活动时间

#### 2.2.5 MockVersions 表（Mock 版本表）

```sql
CREATE TABLE mock_versions (
    id TEXT PRIMARY KEY,
    mock_id TEXT NOT NULL,
    version INTEGER NOT NULL,
    response TEXT NOT NULL,
    headers TEXT,
    description TEXT,
    created_by TEXT,
    created_at TEXT NOT NULL,
    FOREIGN KEY (mock_id) REFERENCES mocks(id) ON DELETE CASCADE,
    FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL,
    UNIQUE(mock_id, version)
);

-- 索引
CREATE INDEX idx_mock_versions_mock_id ON mock_versions(mock_id);
CREATE INDEX idx_mock_versions_version ON mock_versions(mock_id, version DESC);
```

**字段说明：**

- `id`: 版本唯一标识
- `mock_id`: Mock ID（外键）
- `version`: 版本号
- `response`: 响应体
- `headers`: 响应头
- `description`: 描述
- `created_by`: 创建者 ID（外键）
- `created_at`: 创建时间

---

## 三、数据模型（TypeScript）

### 3.1 用户模型

```typescript
// src/storage/models/user.model.ts
export interface User {
  id: string
  email: string
  name: string
  password_hash: string
  role: 'admin' | 'user' | 'viewer'
  created_at: string
  updated_at: string
  last_login_at?: string
}

export interface CreateUserDto {
  email: string
  name: string
  password: string
  role?: 'admin' | 'user' | 'viewer'
}

export interface UpdateUserDto {
  name?: string
  password?: string
  role?: 'admin' | 'user' | 'viewer'
}
```

### 3.2 Mock 模型

```typescript
// src/storage/models/mock.model.ts
export interface Mock {
  id: string
  method: string
  path: string
  status?: number
  response: any
  headers?: Record<string, string>
  cookies?: Record<string, string>
  query_params?: Record<string, string>
  request_headers?: Record<string, string>
  request_body?: any
  delay?: number
  enabled: boolean
  dynamic_response: boolean
  description?: string
  tags?: string[]
  version: number
  created_by?: string
  created_at: string
  updated_at: string
}

export interface CreateMockDto {
  method: string
  path: string
  status?: number
  response: any
  headers?: Record<string, string>
  cookies?: Record<string, string>
  query_params?: Record<string, string>
  request_headers?: Record<string, string>
  request_body?: any
  delay?: number
  enabled?: boolean
  dynamic_response?: boolean
  description?: string
  tags?: string[]
}

export interface UpdateMockDto extends Partial<CreateMockDto> {}

export interface MockQuery {
  method?: string
  path?: string
  enabled?: boolean
  tags?: string[]
  created_by?: string
}
```

### 3.3 请求日志模型

```typescript
// src/storage/models/request.model.ts
export interface RequestLog {
  id: string
  method: string
  url: string
  path: string
  query?: Record<string, string>
  headers: Record<string, string>
  body?: any
  response_status?: number
  response_body?: any
  response_time?: number
  is_mocked: boolean
  mock_id?: string
  ip_address?: string
  user_agent?: string
  timestamp: string
}

export interface RequestQuery {
  method?: string
  path?: string
  is_mocked?: boolean
  mock_id?: string
  start_date?: string
  end_date?: string
  limit?: number
  offset?: number
}
```

---

## 四、数据访问层

### 4.1 Mock Repository

```typescript
// src/storage/repositories/mock.repository.ts
import { Database } from '../database'
import {
  Mock,
  CreateMockDto,
  UpdateMockDto,
  MockQuery,
} from '../models/mock.model'
import { logger } from '../../utils'

export class MockRepository {
  constructor(private db: Database) {}

  async create(
    mock: CreateMockDto & {
      id: string
      created_at: string
      updated_at: string
    },
  ): Promise<Mock> {
    const sql = `
      INSERT INTO mocks (
        id, method, path, status, response, headers, cookies,
        query_params, request_headers, request_body, delay,
        enabled, dynamic_response, description, tags, version,
        created_by, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `

    await this.db.run(sql, [
      mock.id,
      mock.method,
      mock.path,
      mock.status || 200,
      JSON.stringify(mock.response),
      mock.headers ? JSON.stringify(mock.headers) : null,
      mock.cookies ? JSON.stringify(mock.cookies) : null,
      mock.query_params ? JSON.stringify(mock.query_params) : null,
      mock.request_headers ? JSON.stringify(mock.request_headers) : null,
      mock.request_body ? JSON.stringify(mock.request_body) : null,
      mock.delay || 0,
      mock.enabled !== false ? 1 : 0,
      mock.dynamic_response ? 1 : 0,
      mock.description || null,
      mock.tags ? mock.tags.join(',') : null,
      mock.version || 1,
      mock.created_by || null,
      mock.created_at,
      mock.updated_at,
    ])

    return this.findById(mock.id) as Promise<Mock>
  }

  async findById(id: string): Promise<Mock | null> {
    const sql = 'SELECT * FROM mocks WHERE id = ?'
    const row = await this.db.get(sql, [id])

    if (!row) {
      return null
    }

    return this.mapRowToMock(row)
  }

  async findAll(query: MockQuery = {}): Promise<Mock[]> {
    let sql = 'SELECT * FROM mocks WHERE 1=1'
    const params: any[] = []

    if (query.method) {
      sql += ' AND method = ?'
      params.push(query.method)
    }

    if (query.path) {
      sql += ' AND path LIKE ?'
      params.push(`%${query.path}%`)
    }

    if (query.enabled !== undefined) {
      sql += ' AND enabled = ?'
      params.push(query.enabled ? 1 : 0)
    }

    if (query.tags && query.tags.length > 0) {
      const tagConditions = query.tags.map(() => 'tags LIKE ?').join(' OR ')
      sql += ` AND (${tagConditions})`
      query.tags.forEach((tag) => params.push(`%${tag}%`))
    }

    if (query.created_by) {
      sql += ' AND created_by = ?'
      params.push(query.created_by)
    }

    sql += ' ORDER BY created_at DESC'

    const rows = await this.db.all(sql, params)
    return rows.map((row) => this.mapRowToMock(row))
  }

  async update(id: string, updates: UpdateMockDto): Promise<Mock | null> {
    const existing = await this.findById(id)
    if (!existing) {
      return null
    }

    const fields: string[] = []
    const params: any[] = []

    if (updates.method !== undefined) {
      fields.push('method = ?')
      params.push(updates.method)
    }

    if (updates.path !== undefined) {
      fields.push('path = ?')
      params.push(updates.path)
    }

    if (updates.status !== undefined) {
      fields.push('status = ?')
      params.push(updates.status)
    }

    if (updates.response !== undefined) {
      fields.push('response = ?')
      params.push(JSON.stringify(updates.response))
    }

    if (updates.headers !== undefined) {
      fields.push('headers = ?')
      params.push(JSON.stringify(updates.headers))
    }

    if (updates.cookies !== undefined) {
      fields.push('cookies = ?')
      params.push(JSON.stringify(updates.cookies))
    }

    if (updates.query_params !== undefined) {
      fields.push('query_params = ?')
      params.push(JSON.stringify(updates.query_params))
    }

    if (updates.request_headers !== undefined) {
      fields.push('request_headers = ?')
      params.push(JSON.stringify(updates.request_headers))
    }

    if (updates.request_body !== undefined) {
      fields.push('request_body = ?')
      params.push(JSON.stringify(updates.request_body))
    }

    if (updates.delay !== undefined) {
      fields.push('delay = ?')
      params.push(updates.delay)
    }

    if (updates.enabled !== undefined) {
      fields.push('enabled = ?')
      params.push(updates.enabled ? 1 : 0)
    }

    if (updates.dynamic_response !== undefined) {
      fields.push('dynamic_response = ?')
      params.push(updates.dynamic_response ? 1 : 0)
    }

    if (updates.description !== undefined) {
      fields.push('description = ?')
      params.push(updates.description)
    }

    if (updates.tags !== undefined) {
      fields.push('tags = ?')
      params.push(updates.tags.join(','))
    }

    fields.push('version = version + 1')
    fields.push('updated_at = ?')
    params.push(new Date().toISOString())

    params.push(id)

    const sql = `UPDATE mocks SET ${fields.join(', ')} WHERE id = ?`
    await this.db.run(sql, params)

    return this.findById(id)
  }

  async delete(id: string): Promise<boolean> {
    const sql = 'DELETE FROM mocks WHERE id = ?'
    const result = await this.db.run(sql, [id])
    return result.changes > 0
  }

  async count(query: MockQuery = {}): Promise<number> {
    let sql = 'SELECT COUNT(*) as count FROM mocks WHERE 1=1'
    const params: any[] = []

    if (query.enabled !== undefined) {
      sql += ' AND enabled = ?'
      params.push(query.enabled ? 1 : 0)
    }

    const result = await this.db.get(sql, params)
    return result.count
  }

  private mapRowToMock(row: any): Mock {
    return {
      id: row.id,
      method: row.method,
      path: row.path,
      status: row.status,
      response: JSON.parse(row.response),
      headers: row.headers ? JSON.parse(row.headers) : undefined,
      cookies: row.cookies ? JSON.parse(row.cookies) : undefined,
      query_params: row.query_params ? JSON.parse(row.query_params) : undefined,
      request_headers: row.request_headers
        ? JSON.parse(row.request_headers)
        : undefined,
      request_body: row.request_body ? JSON.parse(row.request_body) : undefined,
      delay: row.delay,
      enabled: row.enabled === 1,
      dynamic_response: row.dynamic_response === 1,
      description: row.description,
      tags: row.tags ? row.tags.split(',') : [],
      version: row.version,
      created_by: row.created_by,
      created_at: row.created_at,
      updated_at: row.updated_at,
    }
  }
}
```

### 4.2 Request Repository

```typescript
// src/storage/repositories/request.repository.ts
import { Database } from '../database'
import { RequestLog, RequestQuery } from '../models/request.model'
import { logger } from '../../utils'

export class RequestRepository {
  constructor(private db: Database) {}

  async create(log: Omit<RequestLog, 'id'>): Promise<RequestLog> {
    const id = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    const sql = `
      INSERT INTO requests (
        id, method, url, path, query, headers, body,
        response_status, response_body, response_time,
        is_mocked, mock_id, ip_address, user_agent, timestamp
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `

    await this.db.run(sql, [
      id,
      log.method,
      log.url,
      log.path,
      log.query ? JSON.stringify(log.query) : null,
      JSON.stringify(log.headers),
      log.body ? JSON.stringify(log.body) : null,
      log.response_status,
      log.response_body ? JSON.stringify(log.response_body) : null,
      log.response_time,
      log.is_mocked ? 1 : 0,
      log.mock_id || null,
      log.ip_address || null,
      log.user_agent || null,
      log.timestamp,
    ])

    return this.findById(id) as Promise<RequestLog>
  }

  async findById(id: string): Promise<RequestLog | null> {
    const sql = 'SELECT * FROM requests WHERE id = ?'
    const row = await this.db.get(sql, [id])

    if (!row) {
      return null
    }

    return this.mapRowToLog(row)
  }

  async findAll(query: RequestQuery = {}): Promise<RequestLog[]> {
    let sql = 'SELECT * FROM requests WHERE 1=1'
    const params: any[] = []

    if (query.method) {
      sql += ' AND method = ?'
      params.push(query.method)
    }

    if (query.path) {
      sql += ' AND path LIKE ?'
      params.push(`%${query.path}%`)
    }

    if (query.is_mocked !== undefined) {
      sql += ' AND is_mocked = ?'
      params.push(query.is_mocked ? 1 : 0)
    }

    if (query.mock_id) {
      sql += ' AND mock_id = ?'
      params.push(query.mock_id)
    }

    if (query.start_date) {
      sql += ' AND timestamp >= ?'
      params.push(query.start_date)
    }

    if (query.end_date) {
      sql += ' AND timestamp <= ?'
      params.push(query.end_date)
    }

    sql += ' ORDER BY timestamp DESC'

    if (query.limit) {
      sql += ' LIMIT ?'
      params.push(query.limit)
    }

    if (query.offset) {
      sql += ' OFFSET ?'
      params.push(query.offset)
    }

    const rows = await this.db.all(sql, params)
    return rows.map((row) => this.mapRowToLog(row))
  }

  async delete(id: string): Promise<boolean> {
    const sql = 'DELETE FROM requests WHERE id = ?'
    const result = await this.db.run(sql, [id])
    return result.changes > 0
  }

  async deleteOld(days: number): Promise<number> {
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - days)

    const sql = 'DELETE FROM requests WHERE timestamp < ?'
    const result = await this.db.run(sql, [cutoffDate.toISOString()])
    return result.changes
  }

  private mapRowToLog(row: any): RequestLog {
    return {
      id: row.id,
      method: row.method,
      url: row.url,
      path: row.path,
      query: row.query ? JSON.parse(row.query) : undefined,
      headers: JSON.parse(row.headers),
      body: row.body ? JSON.parse(row.body) : undefined,
      response_status: row.response_status,
      response_body: row.response_body
        ? JSON.parse(row.response_body)
        : undefined,
      response_time: row.response_time,
      is_mocked: row.is_mocked === 1,
      mock_id: row.mock_id,
      ip_address: row.ip_address,
      user_agent: row.user_agent,
      timestamp: row.timestamp,
    }
  }
}
```

---

## 五、数据库迁移

### 5.1 迁移管理器

```typescript
// src/storage/migrations/migration-manager.ts
import { Database } from '../database'
import { logger } from '../../utils'

export interface Migration {
  name: string
  version: number
  up: (db: Database) => Promise<void>
  down: (db: Database) => Promise<void>
}

export class MigrationManager {
  private migrations: Migration[] = []

  constructor(private db: Database) {
    this.registerMigrations()
  }

  private registerMigrations() {
    // 初始迁移
    this.register({
      name: 'initial_schema',
      version: 1,
      up: async (db) => {
        await db.run(`
          CREATE TABLE IF NOT EXISTS users (
            id TEXT PRIMARY KEY,
            email TEXT UNIQUE NOT NULL,
            name TEXT NOT NULL,
            password_hash TEXT NOT NULL,
            role TEXT NOT NULL DEFAULT 'user',
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            last_login_at TEXT
          )
        `)

        await db.run(`
          CREATE TABLE IF NOT EXISTS mocks (
            id TEXT PRIMARY KEY,
            method TEXT NOT NULL,
            path TEXT NOT NULL,
            status INTEGER DEFAULT 200,
            response TEXT NOT NULL,
            headers TEXT,
            cookies TEXT,
            query_params TEXT,
            request_headers TEXT,
            request_body TEXT,
            delay INTEGER DEFAULT 0,
            enabled INTEGER DEFAULT 1,
            dynamic_response INTEGER DEFAULT 0,
            description TEXT,
            tags TEXT,
            version INTEGER DEFAULT 1,
            created_by TEXT,
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL
          )
        `)

        await db.run(`
          CREATE TABLE IF NOT EXISTS requests (
            id TEXT PRIMARY KEY,
            method TEXT NOT NULL,
            url TEXT NOT NULL,
            path TEXT NOT NULL,
            query TEXT,
            headers TEXT NOT NULL,
            body TEXT,
            response_status INTEGER,
            response_body TEXT,
            response_time INTEGER,
            is_mocked INTEGER DEFAULT 0,
            mock_id TEXT,
            ip_address TEXT,
            user_agent TEXT,
            timestamp TEXT NOT NULL,
            FOREIGN KEY (mock_id) REFERENCES mocks(id) ON DELETE SET NULL
          )
        `)

        // 创建索引
        await db.run(
          'CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)',
        )
        await db.run('CREATE INDEX IF NOT EXISTS idx_users_role ON users(role)')
        await db.run(
          'CREATE INDEX IF NOT EXISTS idx_mocks_method_path ON mocks(method, path)',
        )
        await db.run(
          'CREATE INDEX IF NOT EXISTS idx_mocks_enabled ON mocks(enabled)',
        )
        await db.run('CREATE INDEX IF NOT EXISTS idx_mocks_tags ON mocks(tags)')
        await db.run(
          'CREATE INDEX IF NOT EXISTS idx_requests_timestamp ON requests(timestamp DESC)',
        )
        await db.run(
          'CREATE INDEX IF NOT EXISTS idx_requests_method_path ON requests(method, path)',
        )
      },
      down: async (db) => {
        await db.run('DROP TABLE IF EXISTS requests')
        await db.run('DROP TABLE IF EXISTS mocks')
        await db.run('DROP TABLE IF EXISTS users')
      },
    })
  }

  register(migration: Migration) {
    this.migrations.push(migration)
  }

  async migrate(): Promise<void> {
    // 确保迁移表存在
    await this.db.run(`
      CREATE TABLE IF NOT EXISTS schema_migrations (
        version INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        executed_at TEXT NOT NULL
      )
    `)

    // 获取已执行的迁移
    const executed = await this.db.all(
      'SELECT version, name FROM schema_migrations ORDER BY version',
    )
    const executedVersions = new Set(executed.map((m: any) => m.version))

    // 执行未执行的迁移
    for (const migration of this.migrations) {
      if (!executedVersions.has(migration.version)) {
        logger.info(
          `Running migration: ${migration.name} (v${migration.version})`,
        )

        try {
          await migration.up(this.db)

          await this.db.run(
            'INSERT INTO schema_migrations (version, name, executed_at) VALUES (?, ?, ?)',
            [migration.version, migration.name, new Date().toISOString()],
          )

          logger.info(`Migration completed: ${migration.name}`)
        } catch (error) {
          logger.error(`Migration failed: ${migration.name}`, error)
          throw error
        }
      }
    }

    logger.info('All migrations completed')
  }

  async rollback(targetVersion: number): Promise<void> {
    const executed = await this.db.all(
      'SELECT version, name FROM schema_migrations WHERE version > ? ORDER BY version DESC',
      [targetVersion],
    )

    for (const row of executed) {
      const migration = this.migrations.find((m) => m.version === row.version)

      if (migration) {
        logger.info(`Rolling back migration: ${row.name} (v${row.version})`)

        try {
          await migration.down(this.db)

          await this.db.run('DELETE FROM schema_migrations WHERE version = ?', [
            row.version,
          ])

          logger.info(`Rollback completed: ${row.name}`)
        } catch (error) {
          logger.error(`Rollback failed: ${row.name}`, error)
          throw error
        }
      }
    }

    logger.info('Rollback completed')
  }
}
```

---

## 六、性能优化

### 6.1 索引策略

```sql
-- Mock 表的复合索引
CREATE INDEX idx_mocks_method_path_enabled ON mocks(method, path, enabled);
CREATE INDEX idx_mocks_created_by_enabled ON mocks(created_by, enabled);

-- Request 表的复合索引
CREATE INDEX idx_requests_timestamp_is_mocked ON requests(timestamp DESC, is_mocked);
CREATE INDEX idx_requests_path_timestamp ON requests(path, timestamp DESC);
```

### 6.2 查询优化

```typescript
// 批量查询
async findByIds(ids: string[]): Promise<Mock[]> {
  const placeholders = ids.map(() => '?').join(',')
  const sql = `SELECT * FROM mocks WHERE id IN (${placeholders})`
  const rows = await this.db.all(sql, ids)
  return rows.map(row => this.mapRowToMock(row))
}

// 分页查询
async paginate(query: MockQuery, page: number, pageSize: number): Promise<{
  data: Mock[]
  total: number
  page: number
  pageSize: number
  totalPages: number
}> {
  const offset = (page - 1) * pageSize
  const [data, totalResult] = await Promise.all([
    this.findAll({ ...query, limit: pageSize, offset }),
    this.count(query),
  ])

  return {
    data,
    total: totalResult,
    page,
    pageSize,
    totalPages: Math.ceil(totalResult / pageSize),
  }
}
```

### 6.3 缓存策略

```typescript
// 查询缓存
private cache: Map<string, { data: any; timestamp: number }> = new Map()

async findByIdCached(id: string, ttl = 60000): Promise<Mock | null> {
  const cacheKey = `mock:${id}`
  const cached = this.cache.get(cacheKey)

  if (cached && Date.now() - cached.timestamp < ttl) {
    return cached.data
  }

  const data = await this.findById(id)

  if (data) {
    this.cache.set(cacheKey, { data, timestamp: Date.now() })
  }

  return data
}
```

---

## 七、总结

数据库设计方案提供了：

✅ **完整的表结构**：覆盖所有业务需求
✅ **类型安全**：TypeScript 模型定义
✅ **Repository 模式**：清晰的数据访问层
✅ **迁移管理**：版本化的数据库迁移
✅ **性能优化**：索引和缓存策略
✅ **查询灵活性**：支持复杂查询
✅ **数据完整性**：外键约束和级联删除

核心优势：

- **SQLite 开发**：零配置，即插即用
- **PostgreSQL 生产**：高性能，可扩展
- **迁移支持**：无缝切换数据库
- **类型安全**：完整 TypeScript 支持
