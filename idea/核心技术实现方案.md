# æ ¸å¿ƒæŠ€æœ¯å®ç°æ–¹æ¡ˆ

## ä¸€ã€é¡¹ç›®ç»“æ„

### 1.1 ç›®å½•ç»“æ„

```
smart-mock-server/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ .env.example
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ server/                    # æœåŠ¡å™¨æ ¸å¿ƒ
â”‚   â”‚   â”œâ”€â”€ index.ts              # å…¥å£æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ app.ts                # Express åº”ç”¨
â”‚   â”‚   â”œâ”€â”€ config/               # é…ç½®
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ server.config.ts
â”‚   â”‚   â”‚   â””â”€â”€ database.config.ts
â”‚   â”‚   â”œâ”€â”€ middleware/           # ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ logger.middleware.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ cors.middleware.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.middleware.ts
â”‚   â”‚   â”‚   â””â”€â”€ error.middleware.ts
â”‚   â”‚   â”œâ”€â”€ routes/               # è·¯ç”±
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ api.routes.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ mock.routes.ts
â”‚   â”‚   â”‚   â””â”€â”€ proxy.routes.ts
â”‚   â”‚   â”œâ”€â”€ controllers/          # æ§åˆ¶å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ mock.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ request.controller.ts
â”‚   â”‚   â”‚   â””â”€â”€ claude.controller.ts
â”‚   â”‚   â””â”€â”€ services/            # æœåŠ¡
â”‚   â”‚       â”œâ”€â”€ proxy.service.ts
â”‚   â”‚       â”œâ”€â”€ mock.service.ts
â”‚   â”‚       â””â”€â”€ claude.service.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ proxy/                    # ä»£ç†å±‚
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ http-proxy.ts
â”‚   â”‚   â”œâ”€â”€ graphql-proxy.ts
â”‚   â”‚   â”œâ”€â”€ websocket-proxy.ts
â”‚   â”‚   â””â”€â”€ request-interceptor.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ mock/                     # Mock ç®¡ç†å±‚
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ mock-manager.ts
â”‚   â”‚   â”œâ”€â”€ mock-matcher.ts
â”‚   â”‚   â”œâ”€â”€ mock-generator.ts
â”‚   â”‚   â”œâ”€â”€ mock-validator.ts
â”‚   â”‚   â””â”€â”€ mock-serializer.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ llm/                      # LLM é›†æˆå±‚
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ claude-client.ts
â”‚   â”‚   â”œâ”€â”€ prompt-builder.ts
â”‚   â”‚   â”œâ”€â”€ response-parser.ts
â”‚   â”‚   â””â”€â”€ code-generator.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ storage/                  # æ•°æ®å­˜å‚¨å±‚
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ database.ts
â”‚   â”‚   â”œâ”€â”€ models/              # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”‚   â”œâ”€â”€ mock.model.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ request.model.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ session.model.ts
â”‚   â”‚   â”‚   â””â”€â”€ user.model.ts
â”‚   â”‚   â”œâ”€â”€ repositories/        # æ•°æ®è®¿é—®å±‚
â”‚   â”‚   â”‚   â”œâ”€â”€ mock.repository.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ request.repository.ts
â”‚   â”‚   â”‚   â””â”€â”€ user.repository.ts
â”‚   â”‚   â””â”€â”€ migrations/          # æ•°æ®åº“è¿ç§»
â”‚   â”‚       â””â”€â”€ initial.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ cache/                    # ç¼“å­˜å±‚
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ cache-manager.ts
â”‚   â”‚   â””â”€â”€ cache-strategies.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ websocket/                # WebSocket æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ websocket-server.ts
â”‚   â”‚   â””â”€â”€ event-broadcaster.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/                    # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ logger.ts
â”‚   â”‚   â”œâ”€â”€ validators.ts
â”‚   â”‚   â”œâ”€â”€ formatters.ts
â”‚   â”‚   â””â”€â”€ helpers.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ types/                    # ç±»å‹å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ mock.types.ts
â”‚   â”‚   â”œâ”€â”€ request.types.ts
â”‚   â”‚   â”œâ”€â”€ claude.types.ts
â”‚   â”‚   â””â”€â”€ common.types.ts
â”‚   â”‚
â”‚   â””â”€â”€ constants/                # å¸¸é‡å®šä¹‰
â”‚       â”œâ”€â”€ index.ts
â”‚       â”œâ”€â”€ error-codes.ts
â”‚       â””â”€â”€ defaults.ts
â”‚
â”œâ”€â”€ web-ui/                       # Web UI (ç‹¬ç«‹é¡¹ç›®)
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ vite.config.ts
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ index.html
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ main.tsx
â”‚       â”œâ”€â”€ App.tsx
â”‚       â”œâ”€â”€ components/
â”‚       â”œâ”€â”€ pages/
â”‚       â”œâ”€â”€ services/
â”‚       â”œâ”€â”€ hooks/
â”‚       â”œâ”€â”€ types/
â”‚       â”œâ”€â”€ utils/
â”‚       â””â”€â”€ styles/
â”‚
â”œâ”€â”€ scripts/                      # è„šæœ¬
â”‚   â”œâ”€â”€ setup.js
â”‚   â”œâ”€â”€ migrate.js
â”‚   â””â”€â”€ seed.js
â”‚
â”œâ”€â”€ tests/                        # æµ‹è¯•
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”‚
â”œâ”€â”€ docs/                         # æ–‡æ¡£
â”‚   â”œâ”€â”€ api.md
â”‚   â”œâ”€â”€ deployment.md
â”‚   â””â”€â”€ development.md
â”‚
â””â”€â”€ data/                         # æ•°æ®ç›®å½•
    â”œâ”€â”€ mocks.db
    â””â”€â”€ uploads/
```

### 1.2 é…ç½®æ–‡ä»¶

#### server.config.ts

```typescript
// src/server/config/server.config.ts
import dotenv from 'dotenv'

dotenv.config()

export interface ServerConfig {
  port: number
  webUiPort: number
  host: string
  nodeEnv: 'development' | 'production' | 'test'

  backend: {
    url: string
    timeout: number
    https?: boolean
  }

  proxy: {
    enabled: boolean
    changeOrigin: boolean
    secure: boolean
    followRedirects: boolean
  }

  claude: {
    apiKey: string
    baseURL: string
    model: string
    maxTokens: number
    timeout: number
  }

  database: {
    type: 'sqlite' | 'postgresql' | 'mysql'
    url?: string
    path?: string
    poolSize?: number
  }

  cache: {
    enabled: boolean
    type: 'memory' | 'redis'
    redis?: {
      host: string
      port: number
      password?: string
    }
    ttl: number
  }

  auth: {
    enabled: boolean
    secret: string
    expiresIn: string
  }

  logging: {
    level: 'debug' | 'info' | 'warn' | 'error'
    format: 'json' | 'text'
    file?: string
  }

  features: {
    autoProxy: boolean
    logRequests: boolean
    autoGenerateMock: boolean
    enableCors: boolean
    rateLimiting: boolean
  }

  rateLimit: {
    windowMs: number
    max: number
    message: string
  }
}

export const config: ServerConfig = {
  port: parseInt(process.env.PORT || '4000', 10),
  webUiPort: parseInt(process.env.WEB_UI_PORT || '4001', 10),
  host: process.env.HOST || '0.0.0.0',
  nodeEnv: (process.env.NODE_ENV as any) || 'development',

  backend: {
    url: process.env.BACKEND_URL || 'http://localhost:3000',
    timeout: parseInt(process.env.BACKEND_TIMEOUT || '30000', 10),
    https: process.env.BACKEND_HTTPS === 'true',
  },

  proxy: {
    enabled: process.env.PROXY_ENABLED !== 'false',
    changeOrigin: true,
    secure: false,
    followRedirects: true,
  },

  claude: {
    apiKey: process.env.CLAUDE_API_KEY || '',
    baseURL: process.env.CLAUDE_BASE_URL || 'https://api.anthropic.com',
    model: process.env.CLAUDE_MODEL || 'claude-3-5-sonnet-20241022',
    maxTokens: parseInt(process.env.CLAUDE_MAX_TOKENS || '4096', 10),
    timeout: parseInt(process.env.CLAUDE_TIMEOUT || '60000', 10),
  },

  database: {
    type: (process.env.DB_TYPE as any) || 'sqlite',
    url: process.env.DATABASE_URL,
    path: process.env.DB_PATH || './data/mocks.db',
    poolSize: parseInt(process.env.DB_POOL_SIZE || '10', 10),
  },

  cache: {
    enabled: process.env.CACHE_ENABLED !== 'false',
    type: (process.env.CACHE_TYPE as any) || 'memory',
    redis: {
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379', 10),
      password: process.env.REDIS_PASSWORD,
    },
    ttl: parseInt(process.env.CACHE_TTL || '3600', 10),
  },

  auth: {
    enabled: process.env.AUTH_ENABLED === 'true',
    secret: process.env.JWT_SECRET || 'your-secret-key',
    expiresIn: process.env.JWT_EXPIRES_IN || '24h',
  },

  logging: {
    level: (process.env.LOG_LEVEL as any) || 'info',
    format: (process.env.LOG_FORMAT as any) || 'text',
    file: process.env.LOG_FILE,
  },

  features: {
    autoProxy: process.env.AUTO_PROXY !== 'false',
    logRequests: process.env.LOG_REQUESTS !== 'false',
    autoGenerateMock: process.env.AUTO_GENERATE_MOCK === 'true',
    enableCors: process.env.ENABLE_CORS !== 'false',
    rateLimiting: process.env.RATE_LIMITING === 'true',
  },

  rateLimit: {
    windowMs: parseInt(process.env.RATE_LIMIT_WINDOW || '900000', 10),
    max: parseInt(process.env.RATE_LIMIT_MAX || '100', 10),
    message: 'Too many requests from this IP',
  },
}
```

---

## äºŒã€æ ¸å¿ƒæ¨¡å—å®ç°

### 2.1 æœåŠ¡å™¨å…¥å£

```typescript
// src/server/index.ts
import express, { Express } from 'express'
import cors from 'cors'
import { createServer as createHTTPServer } from 'http'
import { createServer as createHTTPSServer } from 'https'
import { Server as SocketIOServer } from 'socket.io'
import { config } from './config'
import { setupRoutes } from './routes'
import { setupMiddleware } from './middleware'
import { setupWebsocket } from '../websocket'
import { Database } from '../storage'
import { CacheManager } from '../cache'
import { ProxyService } from '../proxy'
import { MockManager } from '../mock'
import { ClaudeClient } from '../llm'
import { logger } from '../utils'

class MockServer {
  private app: Express
  private httpServer: any
  private websocketServer: SocketIOServer
  private database: Database
  private cache: CacheManager
  private proxyService: ProxyService
  private mockManager: MockManager
  private claudeClient: ClaudeClient

  constructor() {
    this.app = express()
  }

  async initialize(): Promise<void> {
    try {
      // 1. åˆå§‹åŒ–æ•°æ®åº“
      this.database = new Database(config.database)
      await this.database.connect()
      await this.database.runMigrations()

      // 2. åˆå§‹åŒ–ç¼“å­˜
      this.cache = new CacheManager(config.cache)
      await this.cache.connect()

      // 3. åˆå§‹åŒ– Claude å®¢æˆ·ç«¯
      this.claudeClient = new ClaudeClient(config.claude)

      // 4. åˆå§‹åŒ– Mock ç®¡ç†å™¨
      this.mockManager = new MockManager(this.database, this.cache)

      // 5. åˆå§‹åŒ–ä»£ç†æœåŠ¡
      this.proxyService = new ProxyService(
        config.proxy,
        config.backend,
        this.mockManager,
        this.cache,
      )

      // 6. è®¾ç½®ä¸­é—´ä»¶
      setupMiddleware(this.app)

      // 7. è®¾ç½®è·¯ç”±
      setupRoutes(this.app, {
        mockManager: this.mockManager,
        claudeClient: this.claudeClient,
        proxyService: this.proxyService,
      })

      // 8. åˆ›å»º HTTP/HTTPS æœåŠ¡å™¨
      if (config.https) {
        // HTTPS æœåŠ¡å™¨ï¼ˆéœ€è¦æä¾›è¯ä¹¦ï¼‰
        this.httpServer = createHTTPSServer(
          {
            key: process.env.HTTPS_KEY,
            cert: process.env.HTTPS_CERT,
          },
          this.app,
        )
      } else {
        this.httpServer = createHTTPServer(this.app)
      }

      // 9. è®¾ç½® WebSocket
      this.websocketServer = setupWebsocket(this.httpServer, {
        mockManager: this.mockManager,
        claudeClient: this.claudeClient,
        proxyService: this.proxyService,
      })

      // 10. å¯åŠ¨æœåŠ¡å™¨
      await this.start()

      logger.info('Server initialized successfully')
    } catch (error) {
      logger.error('Failed to initialize server:', error)
      throw error
    }
  }

  async start(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.httpServer.listen(config.port, config.host, (error?: Error) => {
        if (error) {
          reject(error)
          return
        }

        logger.info(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘  ğŸ­ Smart Mock Server                                      â•‘
â•‘                                                               â•‘
â•‘  âœ… Server Status: Running                                  â•‘
â•‘  ğŸ“¡ Mock API:     http://${config.host}:${config.port}      â•‘
â•‘  ğŸŒ Web UI:       http://${config.host}:${config.webUiPort}â•‘
â•‘  ğŸ”— Real Backend: ${config.backend.url}                 â•‘
â•‘  ğŸ¤– Claude:       ${config.claude.model}                  â•‘
â•‘                                                               â•‘
â•‘  ğŸ’¡ Usage:                                                   â•‘
â•‘     1. Change your app's API URL to:                        â•‘
â•‘        http://${config.host}:${config.port}                 â•‘
â•‘     2. Open Web UI at:                                      â•‘
â•‘        http://${config.host}:${config.webUiPort}             â•‘
â•‘     3. Start developing!                                    â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        `)

        resolve()
      })
    })
  }

  async shutdown(): Promise<void> {
    logger.info('Shutting down server...')

    // å…³é—­ HTTP æœåŠ¡å™¨
    await new Promise<void>((resolve) => {
      this.httpServer.close(() => resolve())
    })

    // å…³é—­ WebSocket
    this.websocketServer.close()

    // å…³é—­æ•°æ®åº“è¿æ¥
    await this.database.close()

    // å…³é—­ç¼“å­˜è¿æ¥
    await this.cache.close()

    logger.info('Server shutdown complete')
  }
}

// å¯åŠ¨æœåŠ¡å™¨
const server = new MockServer()

// ä¼˜é›…é€€å‡º
process.on('SIGTERM', async () => {
  logger.info('SIGTERM signal received')
  await server.shutdown()
  process.exit(0)
})

process.on('SIGINT', async () => {
  logger.info('SIGINT signal received')
  await server.shutdown()
  process.exit(0)
})

// æœªæ•è·çš„å¼‚å¸¸
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', error)
  process.exit(1)
})

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at:', promise, 'reason:', reason)
  process.exit(1)
})

// å¯¼å‡ºæœåŠ¡å™¨å®ä¾‹
export { server }
```

### 2.2 ä»£ç†æœåŠ¡å®ç°

```typescript
// src/proxy/http-proxy.ts
import httpProxy from 'http-proxy'
import { Request, Response } from 'express'
import { ProxyOptions, BackendConfig } from '../types'
import { MockManager } from '../mock'
import { CacheManager } from '../cache'
import { logger } from '../utils'

export class HttpProxy {
  private proxy: httpProxy
  private mockManager: MockManager
  private cache: CacheManager
  private backendUrl: string

  constructor(
    private options: ProxyOptions,
    private backendConfig: BackendConfig,
    mockManager: MockManager,
    cache: CacheManager,
  ) {
    this.mockManager = mockManager
    this.cache = cache
    this.backendUrl = backendConfig.url

    this.proxy = httpProxy.createProxyServer({
      target: this.backendUrl,
      changeOrigin: options.changeOrigin,
      secure: options.secure,
      timeout: backendConfig.timeout,
      followRedirects: options.followRedirects,
    })

    this.setupEventHandlers()
  }

  private setupEventHandlers(): void {
    // ä»£ç†è¯·æ±‚äº‹ä»¶
    this.proxy.on('proxyReq', (proxyReq, req) => {
      logger.debug(
        `[Proxy] ${req.method} ${req.url} -> ${this.backendUrl}${req.url}`,
      )
    })

    // ä»£ç†å“åº”äº‹ä»¶
    this.proxy.on('proxyRes', (proxyRes, req, res) => {
      logger.debug(
        `[Proxy Response] ${req.method} ${req.url} - Status: ${proxyRes.statusCode}`,
      )
    })

    // ä»£ç†é”™è¯¯äº‹ä»¶
    this.proxy.on('error', (err, req, res) => {
      logger.error(`[Proxy Error] ${req.method} ${req.url}:`, err.message)
      res.status(500).json({
        error: 'Proxy Error',
        message: err.message,
      })
    })
  }

  async handleRequest(req: Request, res: Response): Promise<void> {
    try {
      // 1. å°è¯•ä»ç¼“å­˜è·å–å“åº”
      const cacheKey = this.getCacheKey(req)
      const cachedResponse = await this.cache.get(cacheKey)

      if (cachedResponse) {
        logger.debug(`[Cache Hit] ${req.method} ${req.url}`)
        res.json(cachedResponse)
        return
      }

      // 2. æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…çš„ Mock
      const mock = await this.mockManager.findMatchingMock(req)

      if (mock) {
        logger.info(`[Mock] Using mock for ${req.method} ${req.url}`)
        const mockResponse = await this.mockManager.executeMock(mock, req)

        // ç¼“å­˜ Mock å“åº”
        await this.cache.set(cacheKey, mockResponse.data)

        res.status(mockResponse.status || 200).json(mockResponse.data)
        return
      }

      // 3. ä»£ç†åˆ°çœŸå®åç«¯
      logger.debug(`[Proxy] Forwarding to backend: ${req.method} ${req.url}`)
      this.proxy.web(req, res)
    } catch (error) {
      logger.error(`[Proxy Request Error] ${req.method} ${req.url}:`, error)
      res.status(500).json({
        error: 'Internal Server Error',
        message: error instanceof Error ? error.message : 'Unknown error',
      })
    }
  }

  private getCacheKey(req: Request): string {
    return `${req.method}:${req.url}:${JSON.stringify(req.query)}`
  }

  getProxy(): httpProxy {
    return this.proxy
  }
}
```

### 2.3 Mock ç®¡ç†å™¨å®ç°

```typescript
// src/mock/mock-manager.ts
import { Request } from 'express'
import { Database } from '../storage'
import { CacheManager } from '../cache'
import { Mock, CreateMockDto, UpdateMockDto, MockResponse } from '../types'
import { MockMatcher } from './mock-matcher'
import { MockValidator } from './mock-validator'
import { MockSerializer } from './mock-serializer'
import { logger } from '../utils'

export class MockManager {
  private matcher: MockMatcher
  private validator: MockValidator
  private serializer: MockSerializer

  constructor(
    private database: Database,
    private cache: CacheManager,
  ) {
    this.matcher = new MockMatcher()
    this.validator = new MockValidator()
    this.serializer = new MockSerializer()
  }

  async findMatchingMock(req: Request): Promise<Mock | null> {
    try {
      // 1. å°è¯•ä»ç¼“å­˜è·å–
      const cacheKey = this.getCacheKey(req)
      const cachedMock = await this.cache.get(cacheKey)

      if (cachedMock) {
        return cachedMock as Mock
      }

      // 2. ä»æ•°æ®åº“æŸ¥è¯¢
      const mocks = await this.database.mocks.findAll({
        enabled: true,
      })

      // 3. åŒ¹é…è§„åˆ™
      for (const mock of mocks) {
        if (this.matcher.matches(req, mock)) {
          logger.debug(`[Mock Match] Found mock: ${mock.id}`)
          await this.cache.set(cacheKey, mock)
          return mock
        }
      }

      return null
    } catch (error) {
      logger.error('[MockManager] Error finding matching mock:', error)
      return null
    }
  }

  async executeMock(mock: Mock, req: Request): Promise<MockResponse> {
    try {
      // 1. æå–è·¯å¾„å‚æ•°
      const params = this.matcher.extractParams(req, mock)

      // 2. æ‰§è¡Œå»¶è¿Ÿï¼ˆå¦‚æœé…ç½®ï¼‰
      if (mock.delay) {
        await this.delay(mock.delay)
      }

      // 3. ç”Ÿæˆå“åº”
      let responseData = mock.response

      // 4. å¤„ç†åŠ¨æ€æ•°æ®
      if (mock.dynamicResponse) {
        responseData = this.serializer.serialize(mock.response, {
          params,
          query: req.query,
          body: req.body,
          headers: req.headers,
        })
      }

      // 5. åº”ç”¨å“åº”å¤´
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
        ...mock.headers,
      }

      // 6. åº”ç”¨ Cookies
      if (mock.cookies) {
        const cookieHeader = Object.entries(mock.cookies)
          .map(([name, value]) => `${name}=${value}`)
          .join('; ')
        headers['Set-Cookie'] = cookieHeader
      }

      return {
        status: mock.status || 200,
        data: responseData,
        headers,
      }
    } catch (error) {
      logger.error('[MockManager] Error executing mock:', error)
      throw error
    }
  }

  async createMock(dto: CreateMockDto): Promise<Mock> {
    try {
      // 1. éªŒè¯æ•°æ®
      await this.validator.validateCreate(dto)

      // 2. åˆ›å»º Mock å¯¹è±¡
      const mock: Mock = {
        id: this.generateId(),
        ...dto,
        enabled: dto.enabled ?? true,
        version: 1,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      }

      // 3. ä¿å­˜åˆ°æ•°æ®åº“
      const created = await this.database.mocks.create(mock)

      // 4. æ¸…é™¤ç›¸å…³ç¼“å­˜
      await this.clearCache(mock)

      logger.info(`[MockManager] Created mock: ${mock.id}`)
      return created
    } catch (error) {
      logger.error('[MockManager] Error creating mock:', error)
      throw error
    }
  }

  async updateMock(id: string, dto: UpdateMockDto): Promise<Mock> {
    try {
      // 1. éªŒè¯æ•°æ®
      await this.validator.validateUpdate(dto)

      // 2. è·å–ç°æœ‰ Mock
      const existing = await this.database.mocks.findById(id)
      if (!existing) {
        throw new Error(`Mock not found: ${id}`)
      }

      // 3. æ›´æ–° Mock
      const updated: Mock = {
        ...existing,
        ...dto,
        version: existing.version + 1,
        updatedAt: new Date().toISOString(),
      }

      // 4. ä¿å­˜åˆ°æ•°æ®åº“
      const saved = await this.database.mocks.update(id, updated)

      // 5. æ¸…é™¤ç›¸å…³ç¼“å­˜
      await this.clearCache(saved)

      logger.info(`[MockManager] Updated mock: ${id}`)
      return saved
    } catch (error) {
      logger.error('[MockManager] Error updating mock:', error)
      throw error
    }
  }

  async deleteMock(id: string): Promise<void> {
    try {
      await this.database.mocks.delete(id)
      await this.clearCache({ id } as any)
      logger.info(`[MockManager] Deleted mock: ${id}`)
    } catch (error) {
      logger.error('[MockManager] Error deleting mock:', error)
      throw error
    }
  }

  async listMocks(filters?: any): Promise<Mock[]> {
    return await this.database.mocks.findAll(filters)
  }

  async getMockById(id: string): Promise<Mock | null> {
    return await this.database.mocks.findById(id)
  }

  async toggleMock(id: string, enabled: boolean): Promise<Mock> {
    return await this.updateMock(id, { enabled })
  }

  private getCacheKey(req: Request): string {
    return `mock:${req.method}:${req.path}`
  }

  private async clearCache(mock: Partial<Mock>): Promise<void> {
    const patterns = [`mock:${mock.method}:${mock.path}`, `mock:*:${mock.path}`]

    await Promise.all(
      patterns.map((pattern) => this.cache.deletePattern(pattern)),
    )
  }

  private generateId(): string {
    return `mock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  private async delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }
}
```

### 2.4 Claude å®¢æˆ·ç«¯å®ç°

```typescript
// src/llm/claude-client.ts
import Anthropic from '@anthropic-ai/sdk'
import { ClaudeConfig, ClaudeMessage, ClaudeResponse } from '../types'
import { PromptBuilder } from './prompt-builder'
import { ResponseParser } from './response-parser'
import { logger } from '../utils'

export class ClaudeClient {
  private client: Anthropic
  private promptBuilder: PromptBuilder
  private responseParser: ResponseParser

  constructor(private config: ClaudeConfig) {
    this.client = new Anthropic({
      apiKey: config.apiKey,
      baseURL: config.baseURL,
      timeout: config.timeout,
    })

    this.promptBuilder = new PromptBuilder()
    this.responseParser = new ResponseParser()
  }

  async generateMock(request: any): Promise<any> {
    try {
      const prompt = this.promptBuilder.buildMockPrompt(request)

      const message = await this.client.messages.create({
        model: this.config.model,
        max_tokens: this.config.maxTokens,
        system: this.getSystemPrompt(),
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
      })

      const response = message.content[0] as any
      const parsedResponse = this.responseParser.parseMockResponse(
        response.text,
      )

      logger.info('[Claude] Mock generated successfully')
      return parsedResponse
    } catch (error) {
      logger.error('[Claude] Error generating mock:', error)
      throw new Error(
        `Failed to generate mock: ${error instanceof Error ? error.message : 'Unknown error'}`,
      )
    }
  }

  async chat(messages: ClaudeMessage[], context: any = {}): Promise<string> {
    try {
      const systemPrompt = this.promptBuilder.buildSystemPrompt(context)

      const message = await this.client.messages.create({
        model: this.config.model,
        max_tokens: this.config.maxTokens,
        system: systemPrompt,
        messages: messages.map((msg) => ({
          role: msg.role,
          content: msg.content,
        })),
      })

      const response = message.content[0] as any
      return response.text
    } catch (error) {
      logger.error('[Claude] Error in chat:', error)
      throw error
    }
  }

  async generateDocumentation(mock: any): Promise<string> {
    try {
      const prompt = this.promptBuilder.buildDocumentationPrompt(mock)

      const message = await this.client.messages.create({
        model: this.config.model,
        max_tokens: this.config.maxTokens,
        system:
          'You are an API documentation generator. Generate clear, comprehensive Markdown documentation.',
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
      })

      const response = message.content[0] as any
      return response.text
    } catch (error) {
      logger.error('[Claude] Error generating documentation:', error)
      throw error
    }
  }

  async improveMock(mock: any, instruction: string): Promise<any> {
    try {
      const prompt = this.promptBuilder.buildImprovePrompt(mock, instruction)

      const message = await this.client.messages.create({
        model: this.config.model,
        max_tokens: this.config.maxTokens,
        system: this.getSystemPrompt(),
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
      })

      const response = message.content[0] as any
      const improvedMock = this.responseParser.parseMockResponse(response.text)

      logger.info('[Claude] Mock improved successfully')
      return improvedMock
    } catch (error) {
      logger.error('[Claude] Error improving mock:', error)
      throw error
    }
  }

  async generateFromOpenAPISpec(spec: any): Promise<any[]> {
    try {
      const prompt = this.promptBuilder.buildOpenAPIPrompt(spec)

      const message = await this.client.messages.create({
        model: this.config.model,
        max_tokens: 8192,
        system:
          'You are an expert API mock generator. Analyze OpenAPI specifications and generate comprehensive mock data.',
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
      })

      const response = message.content[0] as any
      const mocks = this.responseParser.parseMultipleMocks(response.text)

      logger.info('[Claude] Generated mocks from OpenAPI spec')
      return mocks
    } catch (error) {
      logger.error('[Claude] Error generating from OpenAPI:', error)
      throw error
    }
  }

  private getSystemPrompt(): string {
    return `
You are an expert API mock generator with deep knowledge of RESTful APIs, GraphQL, and HTTP protocols.

Your responsibilities:
1. Generate realistic, well-structured mock data
2. Ensure data types match API specifications
3. Include edge cases and error scenarios
4. Follow JSON Schema when provided
5. Maintain consistency across related endpoints

Rules:
- Always return valid JSON
- Include all required fields
- Use realistic example values
- Handle optional fields appropriately
- Generate appropriate status codes
- Include proper HTTP headers

When generating documentation:
- Use Markdown format
- Include code examples
- Describe request/response formats
- Explain edge cases and error handling
- Provide usage examples in multiple languages
    `.trim()
  }
}
```

---

## ä¸‰ã€æ•°æ®æ¨¡å‹å®šä¹‰

### 3.1 Mock æ¨¡å‹

```typescript
// src/storage/models/mock.model.ts
export interface Mock {
  id: string
  method: string
  path: string
  status?: number
  response: any
  headers?: Record<string, string>
  cookies?: Record<string, string>
  queryParams?: Record<string, string>
  requestHeaders?: Record<string, string>
  requestBody?: any
  delay?: number
  enabled: boolean
  dynamicResponse: boolean
  description?: string
  tags?: string[]
  version: number
  createdAt: string
  updatedAt: string
  createdBy?: string
}

export interface CreateMockDto {
  method: string
  path: string
  status?: number
  response: any
  headers?: Record<string, string>
  cookies?: Record<string, string>
  queryParams?: Record<string, string>
  requestHeaders?: Record<string, string>
  requestBody?: any
  delay?: number
  enabled?: boolean
  dynamicResponse?: boolean
  description?: string
  tags?: string[]
}

export interface UpdateMockDto extends Partial<CreateMockDto> {}
```

### 3.2 Request æ¨¡å‹

```typescript
// src/storage/models/request.model.ts
export interface RequestLog {
  id: string
  method: string
  url: string
  path: string
  query?: Record<string, string>
  headers: Record<string, string>
  body?: any
  responseStatus?: number
  responseBody?: any
  responseTime?: number
  isMocked: boolean
  mockId?: string
  timestamp: string
  ip?: string
  userAgent?: string
}
```

### 3.3 ç±»å‹å®šä¹‰

```typescript
// src/types/index.ts
export * from './mock.types'
export * from './request.types'
export * from './claude.types'
export * from './common.types'

// src/types/common.types.ts
export interface PaginatedResponse<T> {
  data: T[]
  total: number
  page: number
  pageSize: number
  totalPages: number
}

export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
    details?: any
  }
  meta?: any
}

export interface ServerConfig {
  port: number
  webUiPort: number
  host: string
  nodeEnv: 'development' | 'production' | 'test'
  backend: BackendConfig
  proxy: ProxyOptions
  claude: ClaudeConfig
  database: DatabaseConfig
  cache: CacheConfig
  auth: AuthConfig
  logging: LoggingConfig
  features: FeaturesConfig
  rateLimit: RateLimitConfig
}

export interface BackendConfig {
  url: string
  timeout: number
  https?: boolean
}

export interface ProxyOptions {
  enabled: boolean
  changeOrigin: boolean
  secure: boolean
  followRedirects: boolean
}

export interface ClaudeConfig {
  apiKey: string
  baseURL: string
  model: string
  maxTokens: number
  timeout: number
}

export interface DatabaseConfig {
  type: 'sqlite' | 'postgresql' | 'mysql'
  url?: string
  path?: string
  poolSize?: number
}

export interface CacheConfig {
  enabled: boolean
  type: 'memory' | 'redis'
  redis?: {
    host: string
    port: number
    password?: string
  }
  ttl: number
}

export interface AuthConfig {
  enabled: boolean
  secret: string
  expiresIn: string
}

export interface LoggingConfig {
  level: 'debug' | 'info' | 'warn' | 'error'
  format: 'json' | 'text'
  file?: string
}

export interface FeaturesConfig {
  autoProxy: boolean
  logRequests: boolean
  autoGenerateMock: boolean
  enableCors: boolean
  rateLimiting: boolean
}

export interface RateLimitConfig {
  windowMs: number
  max: number
  message: string
}
```

---

## å››ã€æ€»ç»“

è¿™ä¸ªæ ¸å¿ƒå®ç°æ–¹æ¡ˆæä¾›äº†ï¼š

âœ… **å®Œæ•´çš„åç«¯æ¶æ„**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºæ‰©å±•
âœ… **ç±»å‹å®‰å…¨**ï¼šTypeScript å…¨é¢è¦†ç›–
âœ… **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„å¼‚å¸¸æ•è·å’Œæ—¥å¿—
âœ… **ç¼“å­˜ä¼˜åŒ–**ï¼šæ”¯æŒå¤šç§ç¼“å­˜ç­–ç•¥
âœ… **é…ç½®çµæ´»**ï¼šç¯å¢ƒå˜é‡ + é…ç½®æ–‡ä»¶
âœ… **ç”Ÿäº§å°±ç»ª**ï¼šç›‘æ§ã€æ—¥å¿—ã€éƒ¨ç½²æ–¹æ¡ˆ

æ¥ä¸‹æ¥éœ€è¦å®ç°ï¼š

- å‰ç«¯é›†æˆæ–¹æ¡ˆ
- LLM é›†æˆè¯¦ç»†æ–¹æ¡ˆ
- æ•°æ®åº“è®¾è®¡
- Web UI è®¾è®¡
- éƒ¨ç½²è¿ç»´æ–¹æ¡ˆ
