# å¢å¼ºç‰ˆæ™ºèƒ½è‡ªåŠ¨åŒ– Mock æœåŠ¡å™¨ - å®Œæ•´æ–¹æ¡ˆ

## ä¸€ã€é¡¹ç›®æ¦‚è¿°

### 1.1 æ ¸å¿ƒç†å¿µ

æ‰“é€ ä¸€ä¸ª**npm åŒ…å½¢å¼çš„ä¸€é”®å¯åŠ¨**ã€**CLI äº¤äº’å¼ç•Œé¢**ã€**æœ¬åœ° LLM é›†æˆ**ã€**æ™ºèƒ½ä»£ç†åˆ†æ**çš„ä¸“ä¸šçº§ Mock æœåŠ¡å™¨ã€‚

### 1.2 ä½¿ç”¨æµç¨‹

```bash
# 1. åˆ›å»ºé¡¹ç›®æ–‡ä»¶å¤¹
mkdir my-mock-server
cd my-mock-server

# 2. å®‰è£…åŒ…
npm install -g @smart-mock/server

# 3. å¯åŠ¨æœåŠ¡å™¨
smart-mock

# 4. åœ¨ CLI ç•Œé¢ä¸­æ“ä½œ
> /help                    # æŸ¥çœ‹å¸®åŠ©
> /connect localhost:3000   # è¿æ¥å‰ç«¯é¡¹ç›®
> /web                     # æ‰“å¼€ Web UI

# 5. åœ¨ Web UI ä¸­
# - æŸ¥çœ‹åˆ†æçš„æ¥å£
# - ä½¿ç”¨æœ¬åœ° Claude ç”Ÿæˆ Mock
# - é…ç½®ä»£ç†å¼€å…³
# - å¯¼å‡º MD æ–‡æ¡£
```

---

## äºŒã€é¡¹ç›®ç»“æ„

### 2.1 ç›®å½•ç»“æ„

```
smart-mock-server/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.cli.json
â”œâ”€â”€ rollup.config.js
â”œâ”€â”€ rollup.config.cli.js
â”œâ”€â”€ vite.config.ts
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ cli/                      # CLI ç•Œé¢
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ cli-interface.ts
â”‚   â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”‚   â”œâ”€â”€ help.command.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ connect.command.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ web.command.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ analyze.command.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ status.command.ts
â”‚   â”‚   â”‚   â””â”€â”€ exit.command.ts
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”œâ”€â”€ terminal.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ colors.ts
â”‚   â”‚   â”‚   â””â”€â”€ input.ts
â”‚   â”‚   â””â”€â”€ types/
â”‚   â”‚       â””â”€â”€ cli.types.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ server/                    # æœåŠ¡å™¨æ ¸å¿ƒ
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ app.ts
â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ server.config.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ llm.config.ts
â”‚   â”‚   â”‚   â””â”€â”€ proxy.config.ts
â”‚   â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â””â”€â”€ services/
â”‚   â”‚
â”‚   â”œâ”€â”€ proxy/                     # ä»£ç†å±‚ï¼ˆå¢å¼ºï¼‰
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ http-proxy.ts
â”‚   â”‚   â”œâ”€â”€ smart-proxy.ts      # æ™ºèƒ½ä»£ç†
â”‚   â”‚   â”œâ”€â”€ interface-analyzer.ts # æ¥å£åˆ†æå™¨
â”‚   â”‚   â””â”€â”€ config-detector.ts   # é…ç½®æ£€æµ‹å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ llm/                       # LLM é›†æˆï¼ˆæœ¬åœ°ï¼‰
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ local-llm-client.ts
â”‚   â”‚   â”œâ”€â”€ claude-code-client.ts
â”‚   â”‚   â”œâ”€â”€ opencode-client.ts
â”‚   â”‚   â”œâ”€â”€ prompt-builder.ts
â”‚   â”‚   â””â”€â”€ response-parser.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ analyzer/                  # å‰ç«¯é¡¹ç›®åˆ†æ
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ project-scanner.ts
â”‚   â”‚   â”œâ”€â”€ api-detector.ts
â”‚   â”‚   â”œâ”€â”€ field-analyzer.ts
â”‚   â”‚   â”œâ”€â”€ framework-detector.ts
â”‚   â”‚   â””â”€â”€ validators/
â”‚   â”‚       â”œâ”€â”€ api-validator.ts
â”‚   â”‚       â””â”€â”€ field-validator.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ storage/                   # æ•°æ®å­˜å‚¨
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ database.ts
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ repositories/
â”‚   â”‚
â”‚   â”œâ”€â”€ websocket/                 # WebSocket
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ event-broadcaster.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ web-ui/                     # Web UIï¼ˆç‹¬ç«‹ï¼‰
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â”œâ”€â”€ vite.config.ts
â”‚   â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ types/
â”‚   â””â”€â”€ constants/
â”‚
â”œâ”€â”€ templates/                  # é¡¹ç›®æ¨¡æ¿
â”‚   â””â”€â”€ README.md
â”‚
â””â”€â”€ bin/                        # CLI å…¥å£
    â””â”€â”€ smart-mock
```

### 2.2 package.json

```json
{
  "name": "@smart-mock/server",
  "version": "1.0.0",
  "description": "Intelligent automated mock server with CLI interface",
  "main": "dist/server/index.js",
  "bin": {
    "smart-mock": "./bin/smart-mock"
  },
  "files": ["dist", "bin", "templates", "README.md"],
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"npm run dev:cli\" \"npm run dev:web\"",
    "dev:server": "tsx watch src/server/index.ts",
    "dev:cli": "tsx watch src/cli/index.ts",
    "dev:web": "cd web-ui && vite",
    "build": "npm run build:server && npm run build:cli && npm run build:web",
    "build:server": "tsx build/server.ts",
    "build:cli": "rollup -c rollup.config.cli.js",
    "build:web": "cd web-ui && vite build",
    "start": "node dist/cli/index.js",
    "test": "vitest",
    "lint": "eslint src --ext .ts",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "http-proxy": "^1.18.1",
    "socket.io": "^4.6.1",
    "ws": "^8.13.0",
    "better-sqlite3": "^9.2.2",
    "commander": "^11.1.0",
    "inquirer": "^9.2.12",
    "chalk": "^5.3.0",
    "ora": "^7.0.1",
    "cli-table3": "^0.6.3",
    "open": "^8.4.2",
    "which": "^4.0.0",
    "glob": "^10.3.10",
    "acorn": "^8.11.3",
    "typescript": "^5.3.3"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.10.6",
    "tsx": "^4.7.0",
    "rollup": "^4.9.6",
    "@rollup/plugin-commonjs": "^25.0.7",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "@rollup/plugin-typescript": "^11.1.5",
    "vite": "^5.0.8",
    "eslint": "^8.56.0",
    "prettier": "^3.1.1",
    "vitest": "^1.1.0",
    "concurrently": "^8.2.2"
  }
}
```

---

## ä¸‰ã€CLI ç•Œé¢å®ç°

### 3.1 CLI ä¸»å…¥å£

```typescript
// src/cli/index.ts
#!/usr/bin/env node
import { createInterface } from './cli-interface'
import { ConfigManager } from '../utils/config-manager'
import { logger } from '../utils/logger'

async function main() {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘  ğŸ­ Smart Mock Server v1.0.0                           â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `)

  try {
    // åŠ è½½é…ç½®
    const configManager = new ConfigManager()
    const config = await configManager.load()

    // åˆ›å»º CLI ç•Œé¢
    const cli = createInterface(config)

    // å¯åŠ¨æœåŠ¡å™¨
    await cli.startServer()

    // æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯
    cli.printWelcome()

    // è¿›å…¥äº¤äº’æ¨¡å¼
    await cli.run()

  } catch (error) {
    logger.error('Failed to start CLI:', error)
    process.exit(1)
  }
}

main()
```

### 3.2 CLI ç•Œé¢

```typescript
// src/cli/cli-interface.ts
import inquirer from 'inquirer'
import chalk from 'chalk'
import ora from 'ora'
import open from 'open'
import { Server } from '../server'
import { ProxyManager } from '../proxy/smart-proxy'
import { LLMManager } from '../llm/local-llm-client'
import { ProjectAnalyzer } from '../analyzer'
import { Config } from '../types'
import { logger } from '../utils/logger'

interface CLIInterfaceOptions {
  config: Config
}

export function createInterface(options: CLIInterfaceOptions) {
  let server: Server | null = null
  let proxyManager: ProxyManager | null = null
  let llmManager: LLMManager | null = null
  let analyzer: ProjectAnalyzer | null = null
  let connectedPort: number | null = null
  let projectPath: string | null = null

  const commands = {
    '/help': {
      description: 'æŸ¥çœ‹å¸®åŠ©ä¿¡æ¯',
      handler: showHelp,
    },
    '/connect': {
      description: 'è¿æ¥åˆ°å‰ç«¯é¡¹ç›®',
      handler: handleConnect,
    },
    '/web': {
      description: 'æ‰“å¼€ Web UI',
      handler: openWebUI,
    },
    '/analyze': {
      description: 'åˆ†æå‰ç«¯é¡¹ç›®',
      handler: handleAnalyze,
    },
    '/status': {
      description: 'æŸ¥çœ‹å½“å‰çŠ¶æ€',
      handler: showStatus,
    },
    '/llm': {
      description: 'é…ç½® LLM è¿æ¥',
      handler: handleLLMConfig,
    },
    '/proxy': {
      description: 'é…ç½®ä»£ç†',
      handler: handleProxyConfig,
    },
    '/export': {
      description: 'å¯¼å‡ºæ–‡æ¡£',
      handler: handleExport,
    },
    '/clear': {
      description: 'æ¸…ç©ºæ—¥å¿—',
      handler: clearLogs,
    },
    '/exit': {
      description: 'é€€å‡º',
      handler: handleExit,
    },
    '/quit': {
      description: 'é€€å‡º',
      handler: handleExit,
    },
  }

  async function startServer() {
    const spinner = ora('Starting Mock Server...').start()

    try {
      server = new Server(options.config)
      await server.start()

      proxyManager = new ProxyManager(options.config)
      await proxyManager.initialize()

      llmManager = new LLMManager(options.config.llm)
      await llmManager.connect()

      analyzer = new ProjectAnalyzer()
      await analyzer.initialize()

      spinner.succeed('Mock Server started successfully!')

      // æ‰“å°æœåŠ¡å™¨ä¿¡æ¯
      console.log(`
${chalk.green('âœ…')} Server Status: Running
${chalk.blue('ğŸ“¡')} Mock API:     ${chalk.cyan(`http://localhost:${options.config.port}`)}
${chalk.magenta('ğŸŒ')} Web UI:       ${chalk.cyan(`http://localhost:${options.config.webUiPort}`)}
${chalk.yellow('ğŸ¤–')} LLM:          ${llmManager.isConnected() ? chalk.green('Connected') : chalk.red('Disconnected')}

Type ${chalk.yellow('/help')} to see available commands.
      `)
    } catch (error) {
      spinner.fail('Failed to start server')
      throw error
    }
  }

  function printWelcome() {
    console.log(`
${chalk.bold.cyan('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')}
${chalk.bold.cyan('  Welcome to Smart Mock Server CLI')}
${chalk.bold.cyan('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')}

${chalk.dim('Smart Mock Server is an intelligent, automated mock server')}
${chalk.dim('with CLI interface and local LLM integration.')}

${chalk.yellow('Quick Start:')}
1. ${chalk.cyan('/connect')} - Connect to your frontend project
2. ${chalk.cyan('/analyze')} - Analyze API endpoints
3. ${chalk.cyan('/web')} - Open Web UI
4. ${chalk.cyan('/help')} - See all commands

${chalk.dim('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')}
    `)
  }

  async function run() {
    while (true) {
      try {
        const { command } = await inquirer.prompt([
          {
            type: 'input',
            name: 'command',
            message: `${chalk.green('smart-mock>')} `,
            validate: (input) => {
              if (!input.trim()) return 'Command is required'
              const cmd = input.trim().split(' ')[0]
              if (!commands[cmd] && !cmd.startsWith('/')) {
                return `Unknown command. Type ${chalk.yellow('/help')} for available commands.`
              }
              return true
            },
          },
        ])

        const args = command.trim().split(' ')
        const cmdName = args[0]
        const cmdArgs = args.slice(1)

        const commandHandler = commands[cmdName]

        if (commandHandler) {
          await commandHandler.handler(cmdArgs)
        } else if (cmdName.startsWith('/')) {
          console.log(chalk.red(`Unknown command: ${cmdName}`))
          console.log(`Type ${chalk.yellow('/help')} for available commands.`)
        } else {
          // å°è¯•ä½œä¸ºå‘½ä»¤æ‰§è¡Œ
          console.log(chalk.red(`Unknown command: ${cmdName}`))
          console.log(`Type ${chalk.yellow('/help')} for available commands.`)
        }
      } catch (error) {
        logger.error('Command execution error:', error)
        console.log(chalk.red('An error occurred. Please try again.'))
      }
    }
  }

  async function showHelp(args: string[]) {
    console.log(`
${chalk.bold.cyan('Available Commands:')}

${chalk.yellow('Connection & Setup:')}
  ${chalk.cyan('/help')}                    ${chalk.dim('Show this help message')}
  ${chalk.cyan('/connect [port]')}          ${chalk.dim('Connect to frontend project (default: 3000)')}
  ${chalk.cyan('/web')}                     ${chalk.dim('Open Web UI in browser')}

${chalk.yellow('Analysis & Management:')}
  ${chalk.cyan('/analyze')}                ${chalk.dim('Analyze frontend project APIs')}
  ${chalk.cyan('/status')}                 ${chalk.dim('Show current status')}
  ${chalk.cyan('/export [format]')}       ${chalk.dim('Export API documentation (md, json)')}

${chalk.yellow('Configuration:')}
  ${chalk.cyan('/llm [type]')}             ${chalk.dim('Configure LLM (claude, opencode)')}
  ${chalk.cyan('/proxy [mode]')}          ${chalk.dim('Configure proxy mode (global, selective)')}

${chalk.yellow('System:')}
  ${chalk.cyan('/clear')}                  ${chalk.dim('Clear terminal logs')}
  ${chalk.cyan('/exit') or ${chalk.cyan('/quit')} ${chalk.dim('Exit the application')}

${chalk.dim('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')}
${chalk.dim('Examples:')}
  ${chalk.dim('> /connect localhost:3000')}
  ${chalk.dim('> /analyze /path/to/frontend/project')}
  ${chalk.dim('> /proxy selective')}
  ${chalk.dim('> /llm claude')}
  ${chalk.dim('> /export md')}
    `)
  }

  async function handleConnect(args: string[]) {
    const spinner = ora('Connecting to frontend project...').start()

    try {
      let port: number
      let path: string | undefined

      // è§£æå‚æ•°
      if (args.length >= 1) {
        if (args[0].startsWith('http')) {
          const url = new URL(args[0])
          port = parseInt(url.port) || 80
        } else if (!isNaN(parseInt(args[0]))) {
          port = parseInt(args[0])
        } else {
          path = args[0]
        }
      }

      if (args.length >= 2 && !isNaN(parseInt(args[1]))) {
        port = parseInt(args[1])
      }

      // äº¤äº’å¼è¾“å…¥
      if (port === undefined) {
        const answers = await inquirer.prompt([
          {
            type: 'input',
            name: 'port',
            message: 'Enter frontend port:',
            default: '3000',
            validate: (input) => {
              const num = parseInt(input)
              if (isNaN(num)) return 'Please enter a valid port number'
              if (num < 1 || num > 65535) return 'Port must be between 1 and 65535'
              return true
            },
          },
        ])
        port = parseInt(answers.port)
      }

      if (path === undefined) {
        const answers = await inquirer.prompt([
          {
            type: 'input',
            name: 'path',
            message: 'Enter frontend project path (optional):',
            default: './',
          },
        ])
        path = answers.path || './'
      }

      // è¿æ¥åˆ°å‰ç«¯é¡¹ç›®
      connectedPort = port
      projectPath = path

      await proxyManager.connectToProject(port, path)

      spinner.succeed(`Connected to frontend at port ${port}`)

      console.log(`
${chalk.green('âœ…')} Connected successfully!
${chalk.blue('ğŸ“¡')} Frontend:      ${chalk.cyan(`http://localhost:${port}`)}
${chalk.yellow('ğŸ“')} Project path:  ${chalk.cyan(path)}
      `)

      // è¯¢é—®æ˜¯å¦ç«‹å³åˆ†æ
      const { shouldAnalyze } = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'shouldAnalyze',
          message: 'Would you like to analyze the project now?',
          default: true,
        },
      ])

      if (shouldAnalyze) {
        await handleAnalyze([path || '.'])
      }
    } catch (error) {
      spinner.fail('Failed to connect to frontend project')
      throw error
    }
  }

  async function openWebUI(args: string[]) {
    const url = `http://localhost:${options.config.webUiPort}`

    try {
      console.log(`Opening ${url} in your browser...`)
      await open(url)
      console.log(chalk.green(`âœ… Web UI opened at ${url}`))
    } catch (error) {
      logger.error('Failed to open Web UI:', error)
      console.log(chalk.red(`âŒ Failed to open Web UI. Please open manually: ${url}`))
    }
  }

  async function handleAnalyze(args: string[]) {
    let projectPath = args[0] || projectPath || '.'

    const spinner = ora('Analyzing frontend project...').start()

    try {
      const result = await analyzer.analyzeProject(projectPath)

      spinner.succeed('Project analysis completed!')

      console.log(`
${chalk.bold.cyan('Analysis Results:')}

${chalk.yellow('Framework:')}      ${result.framework}
${chalk.yellow('APIs Found:')}     ${result.apis.length}
${chalk.yellow('Files Scanned:')}  ${result.filesScanned}

${chalk.dim('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')}

${chalk.bold.cyan('API Endpoints:')}
      `)

      result.apis.forEach((api, index) => {
        const status = api.method === 'GET' ? chalk.blue('GET') :
                      api.method === 'POST' ? chalk.green('POST') :
                      api.method === 'PUT' ? chalk.yellow('PUT') :
                      api.method === 'DELETE' ? chalk.red('DELETE') :
                      api.method

        console.log(`
  ${chalk.dim(`${index + 1}.`)} ${status} ${chalk.cyan(api.path)}
     ${chalk.dim(`   File: ${api.file}`)}
     ${chalk.dim(`   Fields: ${Object.keys(api.fields || {}).join(', ') || 'none'}`)
        `)
      })

      // è¯¢é—®æ˜¯å¦ç”Ÿæˆ Mock
      const { shouldGenerateMocks } = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'shouldGenerateMocks',
          message: 'Would you like to generate mocks for these APIs?',
          default: true,
        },
      ])

      if (shouldGenerateMocks) {
        await generateMocks(result.apis)
      }
    } catch (error) {
      spinner.fail('Failed to analyze project')
      throw error
    }
  }

  async function generateMocks(apis: any[]) {
    const spinner = ora('Generating mocks with AI...').start()

    try {
      for (const api of apis) {
        const mock = await llmManager.generateMock(api)
        await proxyManager.addMock(mock)
      }

      spinner.succeed(`Generated ${apis.length} mocks!`)

      console.log(chalk.green(`âœ… ${apis.length} mocks generated successfully`))
    } catch (error) {
      spinner.fail('Failed to generate mocks')
      throw error
    }
  }

  async function showStatus(args: string[]) {
    console.log(`
${chalk.bold.cyan('System Status:')}

${chalk.yellow('Server:')}           ${server ? chalk.green('Running') : chalk.red('Stopped')}
${chalk.yellow('Port:')}             ${options.config.port}
${chalk.yellow('Web UI:')}          ${options.config.webUiPort}
${chalk.yellow('LLM:')}             ${llmManager ? (llmManager.isConnected() ? chalk.green('Connected') : chalk.red('Disconnected')) : chalk.red('Not configured')}
${chalk.yellow('Proxy:')}           ${proxyManager ? (proxyManager.isConnected() ? chalk.green('Connected') : chalk.red('Disconnected')) : chalk.red('Not configured')}

${connectedPort ? `${chalk.yellow('Frontend Port:')}     ${connectedPort}` : ''}
${projectPath ? `${chalk.yellow('Project Path:')}     ${projectPath}` : ''}
    `)
  }

  async function handleLLMConfig(args: string[]) {
    const llmType = args[0]

    if (!llmType) {
      const { type } = await inquirer.prompt([
        {
          type: 'list',
          name: 'type',
          message: 'Select LLM type:',
          choices: ['claude-code', 'opencode'],
        },
      ])
      await configureLLM(type)
    } else {
      await configureLLM(llmType)
    }
  }

  async function configureLLM(type: string) {
    console.log(chalk.dim(`Configuring ${type}...`))

    const answers = await inquirer.prompt([
      {
        type: 'input',
        name: 'endpoint',
        message: 'Enter LLM endpoint:',
        default: type === 'claude-code' ? 'http://localhost:11434' : 'http://localhost:8080',
      },
      {
        type: 'input',
        name: 'model',
        message: 'Enter model name:',
        default: type === 'claude-code' ? 'claude-3-5-sonnet-20241022' : 'opencode-v3',
      },
      {
        type: 'confirm',
        name: 'save',
        message: 'Save configuration?',
        default: true,
      },
    ])

    if (answers.save) {
      await llmManager.configure({
        type,
        endpoint: answers.endpoint,
        model: answers.model,
      })

      console.log(chalk.green(`âœ… ${type} configured successfully!`))
    }
  }

  async function handleProxyConfig(args: string[]) {
    const mode = args[0]

    if (!mode) {
      const { selectedMode } = await inquirer.prompt([
        {
          type: 'list',
          name: 'selectedMode',
          message: 'Select proxy mode:',
          choices: [
            { name: 'Global - Proxy all requests to mocks', value: 'global' },
            { name: 'Selective - Choose which requests to mock', value: 'selective' },
            { name: 'Disabled - Use real backend only', value: 'disabled' },
          ],
        },
      ])
      await configureProxy(selectedMode)
    } else {
      await configureProxy(mode)
    }
  }

  async function configureProxy(mode: string) {
    await proxyManager.setMode(mode)

    if (mode === 'selective') {
      const answers = await inquirer.prompt([
        {
          type: 'checkbox',
          name: 'mockedApis',
          message: 'Select which APIs to mock:',
          choices: proxyManager.getAvailableApis(),
        },
      ])
      await proxyManager.setSelectiveApis(answers.mockedApis)
    }

    console.log(chalk.green(`âœ… Proxy mode set to ${mode}!`))
  }

  async function handleExport(args: string[]) {
    const format = args[0] || 'md'

    const spinner = ora('Exporting documentation...').start()

    try {
      const docs = await proxyManager.exportDocs(format)
      spinner.succeed('Documentation exported!')

      console.log(chalk.green(`âœ… Documentation exported in ${format.toUpperCase()} format`))
      console.log('\n' + docs)
    } catch (error) {
      spinner.fail('Failed to export documentation')
      throw error
    }
  }

  function clearLogs(args: string[]) {
    console.clear()
    printWelcome()
    console.log(chalk.green('âœ… Terminal logs cleared'))
  }

  async function handleExit(args: string[]) {
    const spinner = ora('Shutting down...').start()

    try {
      if (server) {
        await server.shutdown()
      }

      if (proxyManager) {
        await proxyManager.shutdown()
      }

      if (llmManager) {
        await llmManager.disconnect()
      }

      spinner.succeed('Server stopped!')

      console.log(`
${chalk.green('Thank you for using Smart Mock Server!')}
${chalk.dim('Goodbye! ğŸ‘‹')}
      `)

      process.exit(0)
    } catch (error) {
      spinner.fail('Failed to shutdown gracefully')
      process.exit(1)
    }
  }

  return {
    startServer,
    printWelcome,
    run,
    commands,
  }
}
```

### 3.3 CLI å…¥å£æ–‡ä»¶

```typescript
// bin/smart-mock
#!/usr/bin/env node
require('../dist/cli/index.js')
```

---

## å››ã€æœ¬åœ° LLM é›†æˆ

### 4.1 Claude Code å®¢æˆ·ç«¯

````typescript
// src/llm/claude-code-client.ts
import fetch from 'node-fetch'

export class ClaudeCodeClient {
  private endpoint: string
  private model: string

  constructor(config: { endpoint: string; model: string }) {
    this.endpoint = config.endpoint
    this.model = config.model
  }

  async generateMock(apiSpec: any): Promise<any> {
    const prompt = this.buildPrompt(apiSpec)

    try {
      const response = await fetch(`${this.endpoint}/v1/messages`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.model,
          max_tokens: 4096,
          messages: [
            {
              role: 'user',
              content: prompt,
            },
          ],
        }),
      })

      if (!response.ok) {
        throw new Error(`Claude Code API error: ${response.statusText}`)
      }

      const data = await response.json()
      return this.parseResponse(data)
    } catch (error) {
      console.error('Failed to call Claude Code API:', error)
      throw error
    }
  }

  async chat(messages: any[]): Promise<string> {
    try {
      const response = await fetch(`${this.endpoint}/v1/messages`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.model,
          max_tokens: 4096,
          messages,
        }),
      })

      if (!response.ok) {
        throw new Error(`Claude Code API error: ${response.statusText}`)
      }

      const data = await response.json()
      return data.content[0].text
    } catch (error) {
      console.error('Failed to call Claude Code API:', error)
      throw error
    }
  }

  private buildPrompt(apiSpec: any): string {
    return `
Generate a realistic mock response for the following API endpoint:

Method: ${apiSpec.method}
Path: ${apiSpec.path}
Fields: ${JSON.stringify(apiSpec.fields, null, 2)}
File: ${apiSpec.file}

Requirements:
1. Generate realistic mock data that matches the API fields
2. Include all required fields
3. Use appropriate data types
4. Provide realistic example values
5. Handle edge cases

Response format:
{
  "status": 200,
  "response": { ...mock data... },
  "description": "Description of what this mock represents",
  "tags": ["endpoint_name"]
}
    `.trim()
  }

  private parseResponse(data: any): any {
    const content = data.content[0].text
    const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/)

    if (jsonMatch) {
      return JSON.parse(jsonMatch[1])
    }

    return JSON.parse(content)
  }

  async isConnected(): Promise<boolean> {
    try {
      const response = await fetch(`${this.endpoint}/v1/models`, {
        method: 'GET',
      })
      return response.ok
    } catch {
      return false
    }
  }
}
````

### 4.2 Opencode å®¢æˆ·ç«¯

````typescript
// src/llm/opencode-client.ts
import fetch from 'node-fetch'

export class OpencodeClient {
  private endpoint: string
  private model: string

  constructor(config: { endpoint: string; model: string }) {
    this.endpoint = config.endpoint
    this.model = config.model
  }

  async generateMock(apiSpec: any): Promise<any> {
    const prompt = this.buildPrompt(apiSpec)

    try {
      const response = await fetch(`${this.endpoint}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            {
              role: 'user',
              content: prompt,
            },
          ],
          max_tokens: 4096,
        }),
      })

      if (!response.ok) {
        throw new Error(`Opencode API error: ${response.statusText}`)
      }

      const data = await response.json()
      return this.parseResponse(data)
    } catch (error) {
      console.error('Failed to call Opencode API:', error)
      throw error
    }
  }

  private buildPrompt(apiSpec: any): string {
    return `
Generate a realistic mock response for the following API endpoint:

Method: ${apiSpec.method}
Path: ${apiSpec.path}
Fields: ${JSON.stringify(apiSpec.fields, null, 2)}
File: ${apiSpec.file}

Requirements:
1. Generate realistic mock data that matches the API fields
2. Include all required fields
3. Use appropriate data types
4. Provide realistic example values
5. Handle edge cases

Response format:
{
  "status": 200,
  "response": { ...mock data... },
  "description": "Description of what this mock represents",
  "tags": ["endpoint_name"]
}
    `.trim()
  }

  private parseResponse(data: any): any {
    const content = data.choices[0].message.content
    const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/)

    if (jsonMatch) {
      return JSON.parse(jsonMatch[1])
    }

    return JSON.parse(content)
  }

  async isConnected(): Promise<boolean> {
    try {
      const response = await fetch(`${this.endpoint}/v1/models`, {
        method: 'GET',
      })
      return response.ok
    } catch {
      return false
    }
  }
}
````

### 4.3 LLM ç®¡ç†å™¨

```typescript
// src/llm/local-llm-client.ts
import { ClaudeCodeClient } from './claude-code-client'
import { OpencodeClient } from './opencode-client'
import { LLMConfig } from '../types'

export class LLMManager {
  private client: ClaudeCodeClient | OpencodeClient | null = null

  constructor(private config: LLMConfig) {
    this.initializeClient()
  }

  private initializeClient() {
    if (this.config.type === 'claude-code') {
      this.client = new ClaudeCodeClient({
        endpoint: this.config.endpoint,
        model: this.config.model,
      })
    } else if (this.config.type === 'opencode') {
      this.client = new OpencodeClient({
        endpoint: this.config.endpoint,
        model: this.config.model,
      })
    }
  }

  async connect(): Promise<void> {
    if (!this.client) {
      throw new Error('LLM client not initialized')
    }

    const connected = await this.client.isConnected()
    if (!connected) {
      throw new Error('Failed to connect to LLM service')
    }

    console.log(`âœ… Connected to ${this.config.type}`)
  }

  async disconnect(): Promise<void> {
    this.client = null
    console.log('Disconnected from LLM service')
  }

  async generateMock(apiSpec: any): Promise<any> {
    if (!this.client) {
      throw new Error('LLM client not initialized')
    }

    return await this.client.generateMock(apiSpec)
  }

  async chat(messages: any[]): Promise<string> {
    if (!this.client) {
      throw new Error('LLM client not initialized')
    }

    return await this.client.chat(messages)
  }

  async isConnected(): Promise<boolean> {
    if (!this.client) {
      return false
    }

    return await this.client.isConnected()
  }

  async configure(config: Partial<LLMConfig>): Promise<void> {
    this.config = { ...this.config, ...config }
    this.initializeClient()
    await this.connect()
  }
}
```

---

## äº”ã€æ™ºèƒ½ä»£ç†ç®¡ç†

### 5.1 æ™ºèƒ½ä»£ç†ç®¡ç†å™¨

````typescript
// src/proxy/smart-proxy.ts
import { Request, Response } from 'express'
import { ProxyManager } from './http-proxy'
import { InterfaceAnalyzer } from './interface-analyzer'
import { ConfigDetector } from './config-detector'
import { MockManager } from '../mock'
import { logger } from '../utils/logger'

interface ProxyConfig {
  mode: 'global' | 'selective' | 'disabled'
  frontendPort?: number
  projectPath?: string
  selectiveApis?: string[]
}

export class SmartProxyManager extends ProxyManager {
  private analyzer: InterfaceAnalyzer
  private configDetector: ConfigDetector
  private analyzedApis: Map<string, any> = new Map()
  private proxyMode: ProxyConfig['mode'] = 'global'
  private selectiveApis: Set<string> = new Set()

  constructor(proxyConfig: any, backendConfig: any, mockManager: MockManager) {
    super(proxyConfig, backendConfig, mockManager)
    this.analyzer = new InterfaceAnalyzer()
    this.configDetector = new ConfigDetector()
  }

  async connectToProject(port: number, path: string): Promise<void> {
    this.config.frontendPort = port
    this.config.projectPath = path

    // æ£€æµ‹å‰ç«¯é…ç½®
    const frontendConfig = await this.configDetector.detect(path)
    logger.info('Frontend configuration detected:', frontendConfig)

    // åˆ†ææ¥å£
    const apis = await this.analyzer.analyze(path)
    this.analyzedApis.clear()
    apis.forEach((api) => {
      const key = `${api.method}:${api.path}`
      this.analyzedApis.set(key, api)
    })

    logger.info(`Analyzed ${apis.length} API endpoints`)
  }

  setMode(mode: ProxyConfig['mode']): void {
    this.proxyMode = mode
    logger.info(`Proxy mode set to ${mode}`)
  }

  setSelectiveApis(apiKeys: string[]): void {
    this.selectiveApis.clear()
    apiKeys.forEach((key) => this.selectiveApis.add(key))
    logger.info(`Set ${apiKeys.length} selective APIs`)
  }

  getAvailableApis(): any[] {
    return Array.from(this.analyzedApis.values())
  }

  async handleRequest(req: Request, res: Response): Promise<void> {
    try {
      // å¦‚æœä»£ç†è¢«ç¦ç”¨ï¼Œç›´æ¥è½¬å‘åˆ°åç«¯
      if (this.proxyMode === 'disabled') {
        return await this.proxyToBackend(req, res)
      }

      const apiKey = `${req.method}:${req.path}`

      // å…¨å±€ Mock æ¨¡å¼
      if (this.proxyMode === 'global') {
        // å¦‚æœè¯¥æ¥å£å·²è¢«åˆ†æä¸”æœ‰ Mockï¼Œä½¿ç”¨ Mock
        if (this.analyzedApis.has(apiKey)) {
          const mock = await this.mockManager.findMatchingMock(req)
          if (mock) {
            return await this.mockManager.executeMock(mock, req)
          }
        }

        // å¦åˆ™ä½¿ç”¨çœŸå®åç«¯
        return await this.proxyToBackend(req, res)
      }

      // é€‰æ‹©æ€§ Mock æ¨¡å¼
      if (this.proxyMode === 'selective') {
        // å¦‚æœè¯¥æ¥å£åœ¨é€‰æ‹©åˆ—è¡¨ä¸­
        if (this.selectiveApis.has(apiKey)) {
          const mock = await this.mockManager.findMatchingMock(req)
          if (mock) {
            return await this.mockManager.executeMock(mock, req)
          }
        }

        // å¦åˆ™ä½¿ç”¨çœŸå®åç«¯
        return await this.proxyToBackend(req, res)
      }
    } catch (error) {
      logger.error('Proxy request error:', error)
      res.status(500).json({ error: 'Internal server error' })
    }
  }

  async exportDocs(format: 'md' | 'json'): Promise<string> {
    const apis = this.getAvailableApis()

    if (format === 'md') {
      return this.generateMarkdownDocs(apis)
    } else {
      return JSON.stringify(apis, null, 2)
    }
  }

  private generateMarkdownDocs(apis: any[]): string {
    const lines: string[] = []

    lines.push('# API Documentation')
    lines.push('')
    lines.push(`Generated: ${new Date().toISOString()}`)
    lines.push(`Total APIs: ${apis.length}`)
    lines.push('')

    apis.forEach((api) => {
      lines.push(`## ${api.method} ${api.path}`)
      lines.push('')

      if (api.description) {
        lines.push(api.description)
        lines.push('')
      }

      lines.push(`**File:** \`${api.file}\``)
      lines.push('')

      if (Object.keys(api.fields || {}).length > 0) {
        lines.push('**Fields:**')
        lines.push('')
        lines.push('| Field | Type | Description |')
        lines.push('|-------|------|-------------|')

        Object.entries(api.fields).forEach(([name, field]: any) => {
          lines.push(
            `| \`${name}\` | ${field.type} | ${field.description || '-'} |`,
          )
        })

        lines.push('')
      }

      lines.push('**Example Request:**')
      lines.push('```http')
      lines.push(
        `${api.method} http://localhost:${this.config.frontendPort}${api.path}`,
      )
      lines.push('```')
      lines.push('')

      lines.push('**Example Response:**')
      lines.push('```json')
      lines.push(JSON.stringify(api.exampleResponse || {}, null, 2))
      lines.push('```')
      lines.push('')

      lines.push('---')
      lines.push('')
    })

    return lines.join('\n')
  }

  getProxyMode(): ProxyConfig['mode'] {
    return this.proxyMode
  }

  getSelectiveApisCount(): number {
    return this.selectiveApis.size
  }
}
````

### 5.2 æ¥å£åˆ†æå™¨

```typescript
// src/proxy/interface-analyzer.ts
import { ProjectScanner } from '../analyzer/project-scanner'
import { ApiDetector } from '../analyzer/api-detector'
import { logger } from '../utils/logger'

export class InterfaceAnalyzer {
  private scanner: ProjectScanner
  private detector: ApiDetector

  constructor() {
    this.scanner = new ProjectScanner()
    this.detector = new ApiDetector()
  }

  async analyze(projectPath: string): Promise<any[]> {
    logger.info(`Analyzing project: ${projectPath}`)

    // æ‰«æé¡¹ç›®æ–‡ä»¶
    const files = await this.scanner.scan(projectPath)
    logger.info(`Scanned ${files.length} files`)

    // æ£€æµ‹ API æ¥å£
    const apis: any[] = []
    for (const file of files) {
      const fileApis = await this.detector.detect(file)
      apis.push(...fileApis)
    }

    logger.info(`Detected ${apis.length} API endpoints`)

    return apis
  }
}
```

### 5.3 é…ç½®æ£€æµ‹å™¨

```typescript
// src/proxy/config-detector.ts
import * as fs from 'fs/promises'
import * as path from 'path'

interface FrontendConfig {
  framework: string
  bundler: string
  proxy: any
  devServer: any
}

export class ConfigDetector {
  async detect(projectPath: string): Promise<FrontendConfig> {
    const config: FrontendConfig = {
      framework: 'unknown',
      bundler: 'unknown',
      proxy: null,
      devServer: null,
    }

    // æ£€æµ‹æ¡†æ¶
    if (await this.fileExists(path.join(projectPath, 'package.json'))) {
      const packageJson = await this.readJson(
        path.join(projectPath, 'package.json'),
      )
      config.framework = this.detectFramework(packageJson)
      config.bundler = this.detectBundler(packageJson)
    }

    // æ£€æµ‹ Vite é…ç½®
    const viteConfig = path.join(projectPath, 'vite.config.ts')
    if (await this.fileExists(viteConfig)) {
      config.devServer = await this.parseViteConfig(viteConfig)
    }

    // æ£€æµ‹ Webpack é…ç½®
    const webpackConfig = path.join(projectPath, 'webpack.config.js')
    if (await this.fileExists(webpackConfig)) {
      config.devServer = await this.parseWebpackConfig(webpackConfig)
    }

    return config
  }

  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath)
      return true
    } catch {
      return false
    }
  }

  private async readJson(filePath: string): Promise<any> {
    const content = await fs.readFile(filePath, 'utf-8')
    return JSON.parse(content)
  }

  private detectFramework(packageJson: any): string {
    const dependencies = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    }

    if (dependencies.react) return 'react'
    if (dependencies.vue) return 'vue'
    if (dependencies.angular) return 'angular'
    if (dependencies.svelte) return 'svelte'

    return 'unknown'
  }

  private detectBundler(packageJson: any): string {
    const dependencies = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    }

    if (dependencies.vite) return 'vite'
    if (dependencies.webpack) return 'webpack'
    if (dependencies.rollup) return 'rollup'
    if (dependencies.esbuild) return 'esbuild'

    return 'unknown'
  }

  private async parseViteConfig(configPath: string): Promise<any> {
    // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦ä½¿ç”¨ TypeScript ç¼–è¯‘å™¨
    const content = await fs.readFile(configPath, 'utf-8')

    const proxyMatch = content.match(/proxy:\s*{([^}]+)}/)
    if (proxyMatch) {
      try {
        // å°è¯•è§£æ proxy é…ç½®
        return { proxy: proxyMatch[1] }
      } catch {
        return {}
      }
    }

    return {}
  }

  private async parseWebpackConfig(configPath: string): Promise<any> {
    // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦ä½¿ç”¨ Webpack é…ç½®è§£æå™¨
    const content = await fs.readFile(configPath, 'utf-8')

    if (content.includes('devServer')) {
      return { hasDevServer: true }
    }

    return {}
  }
}
```

---

## å…­ã€å‰ç«¯é¡¹ç›®åˆ†æ

### 6.1 é¡¹ç›®æ‰«æå™¨

```typescript
// src/analyzer/project-scanner.ts
import * as fs from 'fs/promises'
import * as path from 'path'
import { glob } from 'glob'

export class ProjectScanner {
  async scan(projectPath: string): Promise<string[]> {
    const sourceFiles: string[] = []

    // æ‰«æå¸¸è§çš„æºæ–‡ä»¶æ¨¡å¼
    const patterns = [
      '**/*.{js,jsx,ts,tsx}',
      '!**/node_modules/**',
      '!**/dist/**',
      '!**/build/**',
      '!**/.next/**',
      '!**/.nuxt/**',
    ]

    for (const pattern of patterns) {
      const files = await glob(pattern, {
        cwd: projectPath,
        absolute: true,
      })
      sourceFiles.push(...files)
    }

    return [...new Set(sourceFiles)]
  }
}
```

### 6.2 API æ£€æµ‹å™¨

```typescript
// src/analyzer/api-detector.ts
import * as fs from 'fs/promises'
import { logger } from '../../utils/logger'

export class ApiDetector {
  async detect(filePath: string): Promise<any[]> {
    const content = await fs.readFile(filePath, 'utf-8')
    const apis: any[] = []

    // æ£€æµ‹ fetch è°ƒç”¨
    const fetchRegex = /fetch\s*\(\s*['"`]([^'"`]+)['"`]/g
    let match
    while ((match = fetchRegex.exec(content)) !== null) {
      apis.push({
        method: 'GET', // é»˜è®¤ï¼Œéœ€è¦ä»ä¸Šä¸‹æ–‡æ¨æ–­
        path: this.normalizePath(match[1]),
        file: filePath,
        type: 'fetch',
      })
    }

    // æ£€æµ‹ axios è°ƒç”¨
    const axiosRegex =
      /axios\.(get|post|put|delete|patch)\s*\(\s*['"`]([^'"`]+)['"`]/g
    while ((match = axiosRegex.exec(content)) !== null) {
      const method = match[1].toUpperCase()
      const path = match[2]

      apis.push({
        method,
        path: this.normalizePath(path),
        file: filePath,
        type: 'axios',
      })
    }

    // æ£€æµ‹ API å‡½æ•°å®šä¹‰
    const functionRegex =
      /(?:const|function)\s+\w+\s*[=]*\s*(?:async\s*)?\([^)]*).*?=\s*>\s*(?:await\s*)?(fetch|axios\.get|axios\.post)\s*\(\s*['"`]([^'"`]+)['"`]/gs
    while ((match = functionRegex.exec(content)) !== null) {
      apis.push({
        method: 'GET', // éœ€è¦ä»ä¸Šä¸‹æ–‡æ¨æ–­
        path: this.normalizePath(match[2]),
        file: filePath,
        type: 'function',
      })
    }

    logger.debug(`Detected ${apis.length} APIs in ${filePath}`)

    return apis
  }

  private normalizePath(path: string): string {
    // ç§»é™¤åè®®å’ŒåŸŸå
    return path.replace(/^https?:\/\/[^\/]+/, '').replace(/^\//, '/')
  }
}
```

---

## ä¸ƒã€é…ç½®ç®¡ç†

### 7.1 é…ç½®æ–‡ä»¶

```typescript
// src/config/index.ts
export interface Config {
  // æœåŠ¡å™¨é…ç½®
  port: number
  webUiPort: number
  host: string
  nodeEnv: 'development' | 'production'

  // åç«¯é…ç½®
  backend: {
    url: string
    timeout: number
  }

  // ä»£ç†é…ç½®
  proxy: {
    enabled: boolean
    mode: 'global' | 'selective' | 'disabled'
    frontendPort?: number
    projectPath?: string
    selectiveApis?: string[]
  }

  // LLM é…ç½®
  llm: {
    type: 'claude-code' | 'opencode'
    endpoint: string
    model: string
    maxTokens: number
    timeout: number
  }

  // æ•°æ®åº“é…ç½®
  database: {
    type: 'sqlite'
    path: string
  }

  // æ—¥å¿—é…ç½®
  logging: {
    level: 'debug' | 'info' | 'warn' | 'error'
    format: 'text' | 'json'
  }
}

export const defaultConfig: Config = {
  port: 4000,
  webUiPort: 4001,
  host: '0.0.0.0',
  nodeEnv: 'development',

  backend: {
    url: 'http://localhost:3000',
    timeout: 30000,
  },

  proxy: {
    enabled: true,
    mode: 'global' as const,
  },

  llm: {
    type: 'claude-code' as const,
    endpoint: 'http://localhost:11434',
    model: 'claude-3-5-sonnet-20241022',
    maxTokens: 4096,
    timeout: 60000,
  },

  database: {
    type: 'sqlite',
    path: './data/smart-mock.db',
  },

  logging: {
    level: 'info',
    format: 'text',
  },
}
```

---

## å…«ã€æ„å»ºé…ç½®

### 8.1 Rollup é…ç½®ï¼ˆCLIï¼‰

```javascript
// rollup.config.cli.js
import resolve from '@rollup/plugin-node-resolve'
import commonjs from '@rollup/plugin-commonjs'
import typescript from '@rollup/plugin-typescript'

export default {
  input: 'src/cli/index.ts',
  output: {
    dir: 'dist/cli',
    format: 'cjs',
    sourcemap: false,
    exports: 'default',
    banner: '#!/usr/bin/env node',
  },
  plugins: [
    resolve(),
    commonjs(),
    typescript({
      tsconfig: 'tsconfig.cli.json',
      sourceMap: false,
    }),
  ],
  external: ['inquirer', 'chalk', 'ora', 'open', 'which', 'glob', 'acorn'],
}
```

---

## ä¹ã€ä½¿ç”¨ç¤ºä¾‹

### 9.1 å¿«é€Ÿå¼€å§‹

```bash
# 1. å…¨å±€å®‰è£…
npm install -g @smart-mock/server

# 2. åˆ›å»ºé¡¹ç›®
mkdir my-mock-project
cd my-mock-project

# 3. å¯åŠ¨
smart-mock

# 4. åœ¨ CLI ä¸­æ“ä½œ
> /connect localhost:3000
> /analyze
> /web

# 5. åœ¨ Web UI ä¸­
# - æŸ¥çœ‹åˆ†æçš„æ¥å£
# - é…ç½®ä»£ç†æ¨¡å¼
# - ä½¿ç”¨æœ¬åœ° Claude ç”Ÿæˆ Mock
# - å¯¼å‡ºæ–‡æ¡£
```

### 9.2 é…ç½®æ–‡ä»¶

```json
// .smart-mockrc.json
{
  "port": 4000,
  "webUiPort": 4001,
  "backend": {
    "url": "https://api.example.com"
  },
  "llm": {
    "type": "claude-code",
    "endpoint": "http://localhost:11434",
    "model": "claude-3-5-sonnet-20241022"
  },
  "proxy": {
    "mode": "selective",
    "selectiveApis": ["GET:/api/users", "POST:/api/users"]
  }
}
```

---

## åã€æ€»ç»“

è¿™ä¸ªå¢å¼ºç‰ˆæ–¹æ¡ˆæä¾›äº†ï¼š

âœ… **npm åŒ…å½¢å¼**ï¼šä¸€é”®å®‰è£…å¯åŠ¨
âœ… **CLI ç•Œé¢**ï¼šäº¤äº’å¼å‘½ä»¤è¡Œç•Œé¢
âœ… **æœ¬åœ° LLM**ï¼šæ”¯æŒ Claude Code/Opencode
âœ… **æ™ºèƒ½ä»£ç†**ï¼šåˆ†ææ¥å£ã€é…ç½®å¼€å…³
âœ… **é¡¹ç›®åˆ†æ**ï¼šè‡ªåŠ¨æ£€æµ‹å‰ç«¯é¡¹ç›® API
âœ… **æ–‡æ¡£å¯¼å‡º**ï¼šä¸€é”®ç”Ÿæˆ Markdown æ–‡æ¡£
âœ… **è·¨å¹³å°**ï¼šæ”¯æŒ macOSã€Linuxã€Windows

æ ¸å¿ƒæå‡ï¼š

- **npm åŒ…åŒ–**ï¼šç±»ä¼¼ create-react-app çš„ä½“éªŒ
- **CLI äº¤äº’**ï¼šä¸“ä¸šçš„å‘½ä»¤è¡Œç•Œé¢
- **æœ¬åœ° LLM**ï¼šé›¶æˆæœ¬ã€é«˜éšç§
- **æ™ºèƒ½åˆ†æ**ï¼šè‡ªåŠ¨æ£€æµ‹å’ŒéªŒè¯ API
- **çµæ´»ä»£ç†**ï¼šå…¨å±€/é€‰æ‹©æ€§/ç¦ç”¨ä¸‰ç§æ¨¡å¼
- **å®Œå–„æ–‡æ¡£**ï¼šè¯¦ç»†çš„ API æ–‡æ¡£ç”Ÿæˆ
