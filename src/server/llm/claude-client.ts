import Anthropic from '@anthropic-ai/sdk'
import type { Mock, CreateMockDto } from '../mock/manager.js'
import { PromptBuilder } from './prompt-builder.js'
import { ResponseParser } from './response-parser.js'
import pc from 'picocolors'

export interface ClaudeConfig {
  apiKey?: string
  baseURL?: string
  model?: string
  maxTokens?: number
}

export interface GenerateMockRequest {
  method: string
  path: string
  description?: string
  context?: {
    existingMocks?: Mock[]
    projectInfo?: any
  }
}

export class ClaudeClient {
  private client: Anthropic | null = null
  private promptBuilder: PromptBuilder
  private responseParser: ResponseParser
  private config: ClaudeConfig
  private enabled: boolean = false

  constructor(config: ClaudeConfig = {}) {
    this.config = {
      model: config.model || 'claude-sonnet-4-20250514',
      maxTokens: config.maxTokens || 4096,
      baseURL: config.baseURL,
      ...config,
    }

    this.promptBuilder = new PromptBuilder()
    this.responseParser = new ResponseParser()
  }

  async initialize(): Promise<boolean> {
    if (!this.config.apiKey) {
      console.log(pc.yellow('[Claude] API key not configured, AI features disabled'))
      return false
    }

    try {
      this.client = new Anthropic({
        apiKey: this.config.apiKey,
        baseURL: this.config.baseURL,
      })

      // Test connection
      await this.client.messages.create({
        model: this.config.model!,
        max_tokens: 10,
        messages: [{ role: 'user', content: 'ping' }],
      })

      this.enabled = true
      console.log(pc.green('[Claude] Connected successfully'))
      return true
    } catch (error: any) {
      console.error(pc.red('[Claude] Failed to initialize:'), error.message)
      this.enabled = false
      return false
    }
  }

  isEnabled(): boolean {
    return this.enabled
  }

  async generateMock(request: GenerateMockRequest): Promise<Partial<Mock>> {
    if (!this.enabled || !this.client) {
      throw new Error('Claude client not initialized')
    }

    try {
      const prompt = this.promptBuilder.buildMockPrompt(request)
      const systemPrompt = this.promptBuilder.buildSystemPrompt(request.context)

      const response = await this.client.messages.create({
        model: this.config.model!,
        max_tokens: this.config.maxTokens,
        system: systemPrompt,
        messages: [{ role: 'user', content: prompt }],
      })

      const content = response.content[0] as any
      const mockData = this.responseParser.parseMockResponse(content.text)

      console.log(pc.green('[Claude] Mock generated successfully'))

      return {
        name: mockData.name || request.path,
        method: mockData.method || request.method,
        path: mockData.path || request.path,
        status: mockData.status || 200,
        response: mockData.response || { message: 'Generated by AI' },
        headers: mockData.headers,
        delay: mockData.delay || 0,
        enabled: true,
        description: mockData.description || request.description,
        tags: mockData.tags,
      }
    } catch (error: any) {
      console.error(pc.red('[Claude] Error generating mock:'), error.message)
      throw new Error(`Failed to generate mock: ${error.message}`)
    }
  }

  async generateMultipleMocks(spec: any): Promise<Partial<Mock>[]> {
    if (!this.enabled || !this.client) {
      throw new Error('Claude client not initialized')
    }

    try {
      const prompt = this.promptBuilder.buildOpenAPIPrompt(spec)
      const systemPrompt = this.promptBuilder.buildSystemPrompt({})

      const response = await this.client.messages.create({
        model: this.config.model!,
        max_tokens: this.config.maxTokens,
        system: systemPrompt,
        messages: [{ role: 'user', content: prompt }],
      })

      const content = response.content[0] as any
      const mocks = this.responseParser.parseMultipleMocks(content.text)

      console.log(pc.green(`[Claude] Generated ${mocks.length} mocks`))

      return mocks
    } catch (error: any) {
      console.error(pc.red('[Claude] Error generating mocks:'), error.message)
      throw new Error(`Failed to generate mocks: ${error.message}`)
    }
  }

  async chat(messages: { role: string; content: string }[], context: any = {}): Promise<string> {
    if (!this.enabled || !this.client) {
      throw new Error('Claude client not initialized')
    }

    try {
      const systemPrompt = this.promptBuilder.buildSystemPrompt(context)

      const response = await this.client.messages.create({
        model: this.config.model!,
        max_tokens: this.config.maxTokens,
        system: systemPrompt,
        messages: messages,
      })

      const content = response.content[0] as any
      return content.text
    } catch (error: any) {
      console.error(pc.red('[Claude] Error in chat:'), error.message)
      throw new Error(`Chat failed: ${error.message}`)
    }
  }

  async improveMock(mock: Mock, instruction: string): Promise<Partial<Mock>> {
    if (!this.enabled || !this.client) {
      throw new Error('Claude client not initialized')
    }

    try {
      const prompt = this.promptBuilder.buildImprovePrompt(mock, instruction)
      const systemPrompt = this.promptBuilder.buildSystemPrompt({})

      const response = await this.client.messages.create({
        model: this.config.model!,
        max_tokens: this.config.maxTokens,
        system: systemPrompt,
        messages: [{ role: 'user', content: prompt }],
      })

      const content = response.content[0] as any
      const improvedData = this.responseParser.parseMockResponse(content.text)

      console.log(pc.green('[Claude] Mock improved successfully'))

      return improvedData
    } catch (error: any) {
      console.error(pc.red('[Claude] Error improving mock:'), error.message)
      throw new Error(`Failed to improve mock: ${error.message}`)
    }
  }

  async generateDocumentation(mock: Mock): Promise<string> {
    if (!this.enabled || !this.client) {
      throw new Error('Claude client not initialized')
    }

    try {
      const prompt = this.promptBuilder.buildDocumentationPrompt(mock)
      const systemPrompt = this.promptBuilder.buildDocumentationSystemPrompt()

      const response = await this.client.messages.create({
        model: this.config.model!,
        max_tokens: this.config.maxTokens,
        system: systemPrompt,
        messages: [{ role: 'user', content: prompt }],
      })

      const content = response.content[0] as any
      return content.text
    } catch (error: any) {
      console.error(pc.red('[Claude] Error generating documentation:'), error.message)
      throw new Error(`Failed to generate documentation: ${error.message}`)
    }
  }
}

// Singleton instance
let claudeClient: ClaudeClient | null = null

export function getClaudeClient(config?: ClaudeConfig): ClaudeClient {
  if (!claudeClient) {
    claudeClient = new ClaudeClient(config)
  }
  return claudeClient
}
